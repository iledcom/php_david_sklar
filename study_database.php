<?php

/*
Подключение к программе базы данных
Чтобы установить соединение с программой базы данных, следует создать новый объект класса
PDO. В качестве аргумента конструктору класса PDO передается символьная строка, описывающая
подключаемую базу данных. В итоге возвращается объект, которым можно пользоваться в остальной
части программы для обмена информацией с программой базы данных.
В примере 8.1 демонстрируется вызов конструктора данного класса с помощью операции new
PDO() для подключения к базе данных restaurant, развернутой на MySQL-сервере, работающем
по адресу db.example.com. Для доступа к этой базе данных указаны имя пользователя penguin
и пароль top^hat.
*/

Пример 8.1. Подключение к программе базы данных с помощью объекта типа PDO
$db = new PDO('mysql:host=db.example.com;dbname=restaurant',
'penguin','top^hat');

/*
Символьная строка, передаваемая в качестве первого аргумента конструктору класса PDO, назы-
вается именем источника данных (DSN). Она начинается с префикса, обозначающего тип подклю-
чаемой программы базы данных. Затем следует двоеточие (:) и разделяемые точкой с запятой пары
“ключ-значение”, предоставляющие сведения о порядке подключения. Если для подключения к базе
данных требуется указать имя пользователя и пароль, эти сведения передаются в качестве второго
и третьего аргументов конструктору класса PDO.

При удачном исходе операции new PDO() возвращается объект, применяемый для взаимодей-
ствия с базой данных. А если при подключении к ней возникнет затруднение, то будет сгенерировано
исключение типа PDOException. Исключения, которые могут быть сгенерированы конструктором
класса PDO, следует перехватить, чтобы проверить, удалось ли подключиться к базе данных, прежде
чем продолжить выполнение программы. В примере 8.2 показано, как это обычно делается.
*/

Пример 8.2. Перехват исключений, возникающих при ошибках подключения к базе данных
try {
$db = new PDO('mysql:host=localhost;dbname=restaurant',
'penguin','top^hat');
// сделать что-нибудь с объектом в переменной $db
} catch (PDOException $е) {
print "Couldn't connect to the database: " . $e->getMessage();
}

/*
Если в коде из примера 8.2 конструктор класса PDO сгенерирует исключение, то любой код,
следующий в блоке оператора try после операции new PDO(), не будет далее выполнен. Вместо
этого интерпретатор РНР перейдет непосредственно к блоку оператора catch, где отображается
сообщение об ошибке
Так, если пароль top^hat окажется неверным для пользователя penguin, в коде из примера
8.2 будет выведено сообщение, аналогичное следующему:
Couldn't connect to the database: SQLSTATE[HY000] [1045] Access denied
for user 'penguin'@'client.example.com'
(using password: YES)
[ He удалось подключиться к базе данных: SQLSTATE[HY000] [1045]
Отказано в доступе пользователю 'penguin'@'client.example.com'
(пароль использован: ДА) ]
*/

Создание таблицы базы данных
/*
Прежде чем сохранить или извлечь какую-нибудь информацию из таблицы базы данных, ее нуж-
но создать. Как правило, это делается один раз, когда программе на РНР дается команда создать
новую таблицу. А программа на РНР, пользующаяся этой таблицей, сможет читать и записывать в
нее данные всякий раз, когда она выполняется. Но для этого не придется каждый раз воссоздавать
таблицу. Если таблица базы данных похожа на электронную таблицу, то ее построение — на со-
здание файла электронной таблицы. Как только такой файл будет создан, его можно неоднократно
открывать для чтения и внесения в него изменений.
Для создания таблицы базы данных служит команда CREATE TABLE языка SQL, в которой ука-
зывается имя создаваемой таблицы, а также имена и типы всех ее столбцов. В примере 8.3 показано
применение команды CREATE TABLE для создания таблицы dishes, приведенной на рис. 8.1.
*/

Пример 8.3. Создание таблицы dishes в базе данных

/*
CREATE TABLE dishes (
dish_id INTEGER PRIMARY KEY,
dish_name VARCHAR(255),
price DECIMAL(4,2),
is_spicy INT
)
*/
/*
В примере 8.3 создается таблица dishes, состоящая из четырех столбцов dish_id, dish_name,
price и is_spicy и соответствующая виду, приведенному на рис. 8.1. В частности, столбцы
dish_id и is_spicy содержат целочисленные значения, столбец price — десятичные числовые
значения, а столбец dish_name — строковые значения.
После наименования команды CREATE TABLE указывается имя таблицы, а затем список раз-
деляемых запятыми столбцов таблицы в круглых скобках. Предложение, в котором определяется
каждый столбец, состоит из следующих двух частей: имени и типа столбца. Так, в команде из
примера 8.3 указаны имена столбцов dish_id, dish_name, price и is_spicy, а также их типы
INTEGER, VARCHAR(255), DECIMAL(4,2) и INT.
Кроме того, для столбца dish_id указывается дополнительный тип PRIMARY KEY, сообщаю-
щий программе базы данных, что значения в данном столбце не подлежат дублированию в таблице.
Это означает, что конкретное значение из столбца dish_id может одновременно находиться лишь
в одной строке таблицы, что дает возможность программе базы данных, применяемой в примерах
из этой главы, автоматически назначать в столбце dish_id новые единственные целочисленные
значения идентификаторов блюд при вводе новых данных в таблицу dishes. В других программах
баз данных применяется иной синтаксис для автоматического назначения единственных целочис-
ленных значений идентификаторов. Например, в MySQL для этой цели служит ключевое слово
AUTO_INCREMENT, в PostgreSQL — порядковые типы данных, а в Oracle — числовые последова-
тельности.
Как правило, обозначения целочисленных типов данных INT и INTEGER употребляются в коман-
дах SQL попеременно. Но для SQLite характерна необходимость точно указывать целочисленный
тип столбца как INTEGER, чтобы новые единственные значения автоматически назначались в соот-
ветствии с заданным типом столбца PRIMARY KEY.
Для некоторых типов столбцов таблицы в круглых скобках дополнительно указывается длина
или информация о форматировании столбца. Например, тип VARCHAR(255) означает столбец сим-
вольных строк переменной длины, но не более 255 символов, а тип DECIMAL(4,2) — столбец
десятичных чисел с двумя цифрами после десятичной точки и четырьмя цифрами в целом. В табл.
8.2 перечислены типы столбцов, наиболее употребительные в таблицах базы данных.

Таблица 8.2. Типы столбцов, наиболее употребительные в таблицах базы данных
Тип столбца Описание
VARCHAR(length) Символьная строка переменной длины, определяемой параметром
length
INT Целое число
BLOB1 Строковые или двоичные данные длиной до 64 Кбайт
DECIMAL(total_digits,
decimal_places)
Десятичное число, где общее количество цифр определяется
параметром total_digits, а количество цифр после десятичной
точки – параметром decimal_places
DATETIME2 Дата и время, например 1975-03-10 19:45:03 или 2038-01-18
22:14:07
*/

Чтобы создать конкретную таблицу в базе данных, необходимо послать ей запрос SQL с ко-
мандой CREATE TABLE. С этой целью следует вызвать метод ехес() после подключения к базе
данных с помощью операции new PDO(), как показано в примере 8.4.

Пример 8.4. Отправка запроса SQL с командой CREATE TABLE программе базы данных
try {
	$db = new PDO('sqlite:/tmp/restaurant.db');
	$db->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
	$q = $db->exec("CREATE TABLE dishes (
		dish_id INT,
		dish_name VARCHAR(255),
		price DECIMAL(4,2),
		is_spicy INT
	)");
	} catch (PDOException $e) {
	print "Couldn't create table: " . $e->getMessage();
}

/*
Более подробно метод exec() поясняется в следующем разделе. А вызовом метода $db->
setAttribute() в коде из примера 8.4 гарантируется, что расширение PDO сгенерирует исклю-
чения, если возникнут затруднения при обработке запросов, а не подключении к базе данных.
Обработка ошибок средствами PDO также обсуждается в следующем разделе.
В отличие от команды CREATE TABLE, команда DROP TABLE удаляет таблицу вместе с храня-
щейся в ней информацией из базы данных. В примере 8.5 демонстрируется синтаксис запроса SQL
на удаление таблицы dishes из базы данных.
*/

Пример 8.5. Удаление таблицы из базы данных
DROP TABLE dishes
/*Как только таблица будет удалена из базы данных, ее уже нельзя будет восстановить. Поэтому
пользуйтесь командой DROP TABLE осмотрительно!
*/

Ввод информации в базу данных
/*
При удачном исходе подключения к базе данных из операции new PDO() возвращается объект,
предоставляющий доступ к информации в этой базе данных. Вызывая методы этого объекта, можно
посылать запросы SQL программе базы данных и в ответ получать от нее результаты.
*/

Чтобы ввести какую-нибудь информацию в базу данных, следует передать запрос SQL с 
командой INSERT методу ехес() этого объекта, как показано в примере 8.6.

/*
PDO::exec — Выполняет SQL-запрос и возвращает количество затронутых строк
PDO::exec() запускает SQL-запрос на выполнение и возвращает количество строк, задействованых 
в ходе его выполнения.

PDO::exec() не возвращает результат выборки оператором SELECT. Если вам нужно выбрать данные 
этим оператором единожды в ходе выполнения программы, воспользуйтесь методом PDO::query(). 
Если требуется запускать один и тот же запрос на выборку множество раз, лучше создать 
подготовленный запрос PDOStatement методом PDO::prepare(), а затем запускать его методом 
PDOStatement::execute() столько раз, сколько потребуется.

Список параметров:
statement
SQL-выражение, которое необходимо подготовить и запустить.
Данные внутри запроса должны быть правильно экранированы.

Возвращаемые значения
PDO::exec() возвращает количество строк, которые были модифицированы или удалены в ходе его 
выполнения. Если таких строк нет, PDO::exec() вернет 0.

Внимание
Эта функция может возвращать как логическое значение FALSE, так и значение не типа boolean, 
которое приводится к FALSE. За более подробной информацией обратитесь к разделу Булев тип. 
Используйте оператор === для проверки значения, возвращаемого этой функцией.
*/

Пример 8.6. Ввод информации в базу данных с помощью метода ехес()
try {
	$db = new PDO('sqlite:/tmp/restaurant.db');
	$db->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
	$affectedRows = $db->exec(
	"INSERT INTO dishes (dish_name, price, is_spicy)
	VALUES ('Sesame Seed Puff', 2.50, 0)");
} catch (PDOException $e) {
	print "Couldn't insert a row: " . $e->getMessage();
}

/*
Если же при выполнении команды INSERT возникнут какие-нибудь затруднения, то будет сгене-
рировано соответствующее исключение. В примере 8.7 демонстрируется попытка выполнить команду
INSERT с неверно указанным именем dish_size столбца, который отсутствует в таблице dishes.
*/
Пример 8.7. Проверка ошибок выполнения запроса SQL с помощью метода ехес()
try {
	$db = new PDO('sqlite:/tmp/restaurant.db');
	$db->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
	$affectedRows = $db->exec(
	"INSERT INTO dishes (dish_size, dish_name,
	price, is_spicy)
	VALUES ('large', 'Sesame Seed Puff',
	2.50, 0)");
} catch (PDOException $e) {
	print "Couldn't insert a row: " . $e->getMessage();
}
/*
Благодаря тому что вызов метода $db->setAttribute[) предписывает расширению PDO сгенерировать 
исключение в любой момент, когда возникнет ошибка, при выполнении кода из примера 8.7 на экран 
выводится следующее сообщение:
Couldn't insert a row: SQLSTATE[HY000]: General error: 1 table dishes
has no column named dish_size
[ He удалось ввести строку в таблицу: SQLSTATE[HYOOO]: Общая ошибка: 1
В таблица dishes отсутствует столбец с именем dish_size ]

В расширении PDO имеются три режима выдачи ошибок: исключения, негласный и предупреждения. 
Режим исключения при ошибках, активизируемый при вызове метода $db->setAttribute
(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION), лучше всего подходит для целей отладки,
поскольку он позволяет убедиться в отсутствии ошибок при обращении к базе данных. Если не
обработать исключение, генерируемое средствами PDO, выполнение программы на РНР прервется.
Два других режима выдачи ошибок требуют проверки значений, возвращаемых из вызовов ме-
тодов PDO, чтобы сначала определить, возникла ли ошибка, а затем воспользоваться дополнитель-
ными методами PDO для поиска информации о данной ошибке. Негласный режим выдачи ошибок
устанавливается по умолчанию. Как и остальные методы PDO, метод ехес() возвращает логическое
значение false, если ему не удастся выполнить свою задачу. В примере 8.8 проверяется значение,
возвращаемое методом ехес(), а затем из расширения PDO вызывается метод errorInfо() для
получения подробных сведений о возникшей ошибке.

*/

Пример 8.8. Работа с базой данных в негласном режиме выдачи ошибок
// Конструктор всегда генерирует исключение,
// если ему не удастся выполнить свою задачу
try {
	$db = new PDO('sqlite:/tmp/restaurant.db');
} catch (PDOException $e) {
	print "Couldn't connect: " . $e->getMessage();
}

$result = $db->exec("INSERT INTO dishes (dish_size, dish_name, price, is_spicy)
VALUES ('large', 'Sesame Seed Puff', 2.50, 0)");
if (false === $result) {
	$error = $db->errorInfo();
	print "Couldn't insert!\n";
	print "SQL Error={$error[0]}, DB Error={$error[1]},
	Message={$error[2]}\n";
}

/*
При выполнении кода из примера 8.8 на экран выводится следующее сообщение:
Couldn't insert! SQL Error=HY000, DB Error=1, Message=table dishes has no 
column named dish_size
[ Вставить не удалось! Ошибка SQL=HY000, Ошибка БД=1, Сообщение= В таблице отсутствует 
столбец с именем dish_size ]

PDO::errorInfo
(PHP 5 >= 5.1.0, PHP 7, PECL pdo >= 0.1.0)

PDO::errorInfo — Получает расширенную информацию об ошибке, произошедшей в ходе последнего 
обращения к базе данных

Описание
public PDO::errorInfo ( void ) : array
Возвращаемые значения ¶
PDO::errorInfo() возвращает массив с информацией об ошибке, произошедшей в ходе выполнения 
последней операции с базой данных. Массив содержит как минимум следующие поля:

Элемент	Информация
0	Код ошибки SQLSTATE (пятисимвольный идентификатор, определенный в стандарте ANSI SQL).
1	Код ошибки, заданный драйвером.
2	Сообщение об ошибке, заданное драйвером
Замечание:

Если не задан SQLSTATE код или драйвер не сообщил об ошибке, то элементы следующие за нулевым 
будут иметь значение NULL.

PDO::errorInfo() выдает информацию об ошибке только для операций, совершаемых с базой данных 
напрямую из PDO. Если создать объект PDOStatement методами PDO::prepare() или PDO::query(), и 
вызвать ошибку его методами, PDO::errorInfo() эту ошибку не отобразит. Вам нужно вызвать 
PDOStatement::errorInfo(), чтобы получить информации об ошибках для операции, выполняемой на 
определенном объекте PDOStatement.


В коде из примера 8.8 значение, возвращаемое из метода ехес(), сравнивается с логическим
значением false с помощью операции тождественности (===), чтобы отличить фактическую ошиб-
ку (false) от успешного выполнения запроса, который просто не затронул ни одной из строк в
таблице. Затем метод errorInfo() возвращает трехэлементный массив со сведениями о возник-
шей ошибке. Первый элемент этого массива содержит код ошибки SQLSTATE, Такие коды ошибок
в основном стандартизированы в разных программах баз данных. В данном случае возвращается
универсальный код HY000 для всех общих ошибок. Второй элемент данного массива содержит код
ошибки, характерный для конкретной применяемой базы данных. И третий элемент данного массива
содержит текст сообщения, описывающего возникшую ошибку.
Режим предупреждения об ошибках активизируется при установке значения PDO::ERRMODE
_WARNING в атрибуте PDO::ATTR_ERRMODE, как показано в примере 8.9. В этом режиме методы
PDO ведут себя таким же образом, как и в негласном режиме, т.е. при появлении ошибки ника-
ких исключений не возникает, а просто возвращается логическое значение false. Но, кроме того,
интерпретатор РНР формирует сообщение об ошибке на уровне предупреждения. Это сообщение
может быть отображено на экране или выведено в файл регистрации в зависимости о того, каким
образом в программе организована обработка ошибок. О том, как организовать вывод сообщений об
ошибках, речь пойдет в разделе “Управление выводом сообщений об ошибках” главы 12.
*/

Пример 8.9. Работа с базой данных в режиме предупреждения об ошибках
// Конструктор всегда генерирует исключение,
// если ему не удастся выполнить свою задачу
try {
	$db = new PDO('sqlite:/tmp/restaurant.db');
} catch (PDOException $e) {
	print "Couldn't connect: " . $e->getMessage();
}
$db->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_WARNING);
$result = $db->exec("INSERT INTO dishes (dish_size, dish_name, price, is_spicy)
VALUES ('large', 'Sesame Seed Puff', 2.50, 0)");
if (false === $result) {
	$error = $db->errorInfo();
	print "Couldn't insert!\n";
	print "SQL Error={$error[0]}, DB Error={$error[1]},
	Message={$error[2]}\n";
}
/*
Выполнение кода из примера 8.9 приводит к такому же результату, как и в примере 8.8, но на
экран выводится следующее предупреждающее сообщение:
РНР Warning: PDO::exec(): SQLSTATE[HY000]:
General error: 1 table dishes
has no column named dish_size in error-warning.php on line 10
[ Предупреждение PHP::exec(): SQLSTATE[HY000]: Общая ошибка: 1
В таблице отсутствует столбец с именем dish_size, указанный в
строке код 10 исходного файла error-warning.php ]
*/


Урок языка SQL: команда INSERT
/*
Команда INSERT вводит строку в таблицу базы данных. Синтаксис команды INSERT приведен в
примере 8.10.

Пример 8.10. Ввод данных
INSERT INTO имя_таблицы (столбец1[,столбец2, столбец3, ...])
VALUES (значение1[,значение2, значение3, ...])
По запросу SQL с командой INSERT из примера 8.11 новое блюдо вводится в таблицу dishes.
Пример 8.11. Ввод нового блюда в таблицу
INSERT INTO dishes (dish_id, dish_name, price, is_spicy)
VALUES (1, 'Braised Sea Cucumber', 6.50, 0)
Такие строковые значения, как Braised Sea Cucumber (Жареный морской огурец), должны
быть заключены в одиночные кавычки, когда они применяются в запросе SQL. А поскольку
одиночные кавычки служат в качестве ограничителей символьных строк, то их необходимо
экранировать, указав по две одиночные кавычки подряд в составляемом запросе. В примере 8.12
демонстрируется, как ввести блюдо General Tso's Chicken (Цыпленок генерала Цо) в
таблицу dishes.

Пример 8.12. Заключение строкового значения в кавычки
INSERT INTO dishes (dish_id, dish_name, price, is_spicy)
VALUES (2, 'General Tso''s Chicken', 6.75, 1)
Количество столбцов, перечисляемых в круглых скобках перед предложением VALUES, должно
совпадать с количеством значений, указываемых в круглых скобках после предложения VALUES.
Чтобы ввести строку, содержащую значения лишь для некоторых столбцов таблицы, достаточно
перечислить в запросе SQL эти столбцы и их соответствующие значения, как в примере 8.13.

Пример 8.13. Ввод строки со значениями для некоторых столбцов таблицы
INSERT INTO dishes (dish_name, is_spicy)
VALUES ('Salt Baked Scallops', 0)

Пример 8.14. Ввод строки со значениями для всех столбцов таблицы
INSERT INTO dishes
VALUES (1, 'Braised Sea Cucumber', 6.50, 0)
*/

/*
Чтобы изменить данные в таблице, следует составить запрос SQL с командой UPDATE и вызвать
метод ехес(). В примере 8.15 приведены некоторые образцы запросов SQL с командой UPDATE,
выполняемых с помощью метода ехес().
*/
Пример 8.15. Изменение данных в таблице с помощью метода ехес()
try {
	$db = new PDO('sqlite:/tmp/restaurant.db');
	$db->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
	// Кабачок под соусом, приправленным красным стручковым
	// перцем, считается блюдом со специями. Если не имеет
	// значения, сколько строк таблицы затронет данный запрос,
	// то сохранять значение, возвращаемое методом ехес(),
	// совсем не обязательно
	$db->exec("UPDATE dishes SET is_spicy = 1 WHERE dish_name = 'Eggplant with Chili Sauce'");
	// Омар под соусом, приправленным красным стручковым
	// перцем, считается дорогим блюдом со специями
	$db->exec("UPDATE dishes SET is_spicy = 1, price=price * 2 WHERE dish_name = 'Lobster with Chili Sauce'");
} catch (PDOException $e) {
	print "Couldn't insert a row: " . $e->getMessage();
}

/*
Чтобы удалить данные из таблицы, следует составить запрос SQL с командой DELETE и снова
вызвать метод ехес(). В примере 8.16 приведены два запроса SQL с командой DELETE, выполняе-
мых с помощью метода ехес().
*/
Пример 8.16. Удаление данных из таблицы с помощью метода ехес()
try {
	$db = new PDO('sqlite:/tmp/restaurant.db');
	$db->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
	// удалить дорогие блюда из таблицы
	if ($make_things_cheaper) {
		$db->exec("DELETE FROM dishes WHERE price > 19.95");
	} else {
		// или же удалить из нее все блюда
		$db->exec("DELETE FROM dishes");
	}
} catch (PDOException $e) {
	print "Couldn't delete rows: " . $e->getMessage();
}

/*

Урок языка SQL: команда UPDATE
Команда UPDATE изменяет данные, уже находящиеся в таблице. Синтаксис команды UPDATE
показан в примере 8.17.
Пример 8.17. Обновление данных в таблице
UPDATE имя_таблицы SET столбец1= значение1[,столбец2= значение2,
столбец3= значение3, ...] [WHERE логическое_выражение]
Значение, которое изменяется в столбце, может быть строковым или числовым, как показано в
примере 8.18. Строки кода, начинающиеся в примере 8.18 со знака ;, содержат комментарии к
запросу SQL.
Пример 8.18. Установка строкового или числового значения в столбце таблицы
; изменить цену на 5.50 во всех строках таблицы
UPDATE dishes SET price = 5.50
; изменить на 1 значение в столбце is_spicy во всех строках таблицы
UPDATE dishes SET is_spicy = 1
В качестве значения может быть также указано выражение, включающее имена столбцов таблицы.
Так, по запросу SQL в примере 8.19 удваивается цена каждого блюда.
Пример 8.19. Употребление имени столбца в выражении, указываемом в команде UPDATE
UPDATE dishes SET price = price * 2
В рассмотренных до сих пор запросах SQL с командой UPDATE изменялись все строки в таблице
dishes. Чтобы изменить только некоторые строки, в запрос SQL с командой UPDATE следует ввести
предложение WHERE с логическим выражением, описывающим изменяемые строки. Таким образом,
изменения по такому запросу произойдут только в тех строках таблицы, которые совпадают с
условием, заданным в предложении WHERE. В примере 8.20 демонстрируются два запроса SQL с
командой UPDATE, содержащей предложение WHERE.
Пример 8.20. Употребление предложения WHERE в команде UPDATE
; изменить состояние блюда "Кабачок под соусом, приправленным
; красным стручковым перцем" на блюдо со специями
UPDATE dishes SET is_spicy = 1
WHERE dish_name = 'Eggplant with Chili Sauce'
; уменьшить цену на блюдо "Цыпленок генерала Цо"
UPDATE dishes SET price = price - 1
WHERE dish_name = 'General Tso's Chicken'
Более подробно предложение WHERE поясняется далее, во врезке “Урок языка SQL: команда
SELECT”.
*/

/*
Напомним, что метод ехес() возвращает количество строк таблицы, измененных или удаленных
по команде UPDATE или DELETE соответственно. Возвращаемым значением можно воспользоваться,
чтобы выяснить, сколько строк таблицы было затронуто при выполнении запроса SQL. Так, в при-
мере 8.21 сообщается, в каком количестве строк таблицы были изменены цены на блюда по запросу
SQL с командой UPDATE.
*/

Пример 8.21. Выявление количества строк таблицы, затронутых при выполнении запроса SQL
с командой UPDATE
// увеличить цены на некоторые блюда
$count = $db->exec("UPDATE dishes SET price * price + 5 WHERE price > 3");
print 'Changed the price of ' . $count . ' rows.';
Если в таблице dishes будут найдены две строки, где цена на блюдо превышает 3, то при
выполнении кода из примера 8.21 на экран будет выведен следующий результат:
Changed the price of 2 rows.

/*

Урок языка SQL: команда DELETE
Команда DELETE удаляет строки из таблицы. В примере 8.22 приведен синтаксис команды DELETE.
Пример 8.22. Удаление отдельных строк из таблицы
DELETE FROM имя_таблицы [WHERE логическое_выражение]
В отсутствие предложения WHERE команда DELETE удалит все строки из таблицы. Так, в примере
8.23 очищается вся таблица dishes.
Пример 8.23. Удаление всех строк из таблицы
DELETE FROM dishes
При наличии предложения WHERE команда DELETE удалит из таблицы только те строки, которые
совпадают с условием, указанным в предложении WHERE. В примере 8.24 приведены два запроса
SQL с командой DELETE, содержащей предложение WHERE.
Пример 8.24. Удаление некоторых строк из таблицы
; удалить из таблицы строки, где цена на блюда превышает 10.00
DELETE FROM dishes WHERE price > 10.00
; удалить из таблицы строки, где значение в столбце dish_name
; точно соответствует наименованию блюда "Walnut Bun" (Булочка
; с грецкими орехами)
DELETE FROM dishes WHERE dish_name = 'Walnut Bun'
В языке SQL отсутствует команда UNDELETE, поэтому осмотрительно пользуйтесь командой
DELETE.
*/

/*
Безопасный ввод данных из формы
Как пояснялось в разделе “HTML и JavaScript” главы 7, вывод на экран не прошедших сани-
тарную очистку данных из формы может сделать веб-сайт и его посетителей уязвимыми к атакам
типа межсайтового выполнения сценариев. Уязвимость к аналогичным атакам типа умышленного
внесения запросов SQL может вызвать применение не прошедших санитарную очистку данных из
формы в запросах SQL. Рассмотрим в качестве примера форму, в которой пользователь может пред-
ложить новое блюдо. Эта форма содержит текстовый элемент new_dish_name, где пользователь
может ввести название нового блюда. В примере 8.25 новое блюдо вводится в таблицу dishes с по-
мощью метода ехес(), но такой способ уязвим к атакам типа умышленного внесения запросов SQL.
*/

Пример 8.25. Небезопасный ввод данных из формы
$db->exec("INSERT INTO dishes (dish_name) VALUES ('$_POST[new_dish_name]')");

/*
Если переданное значение приемлемо для сохранения в столбце new_dish_name таблицы dishes
(например, название блюда Fried Bean Curd), то запрос будет выполнен успешно. В соответствии
с обычными для РНР правилами вставки символьных строк, заключаемых в двойные кавычки, за-
прос с командой

INSERT INTO dishes (dish_name) VALUES ('Fried Bean Curd')

оказывается вполне приемлемым и достоверным. Но если в запросе имеется знак апострофа, то
может возникнуть осложнение. Так, если для сохранения в столбце new_dish_name передано
наименование блюда General Tso’s Chicken, то запрос на его ввод в таблицу будет следующим:

INSERT INTO dishes (dish_name) VALUES ('General Tso's Chicken')

Такой запрос может вызвать недоразумение в программе базы данных. Она посчитает, что апо-
строф между символами Tso и s завершает символьную строку, и поэтому символы s Chicken’,
следующие после второй одиночной кавычки, будут расценены как нежелательная синтаксическая
ошибка.

Хуже того, пользователь, умышленно стремящийся вызвать осложнения, может ввести специ-
ально составленные данные, чтобы нанести серьезный ущерб. Рассмотрим следующие неприглядные
входные данные:
х'); DELETE FROM dishes; INSERT INTO dishes (dish_name) VALUES ('y.
При вставке эти данные превращаются в следующий запрос:
INSERT INTO DISHES (dish_name) VALUES ('x');
DELETE FROM dishes; INSERT INTO dishes (dish_name) VALUES ('у')
В некоторых базах данных допускается передавать несколько запросов, разделяемых точками с
запятой в одном вызове метода ехес(). В таких базах данных приведенные выше входные данные
могут вызвать серьезные нарушения в таблице dishes, поскольку сначала вводится блюдо х, затем
удаляются все блюда и далее вводится блюдо у.

Передав специально составленное значение в форме, злонамеренный пользователь может внести
произвольные команды SQL в программу базы данных. Во избежание этого следует экранировать
специальные символы (и прежде всего, апостроф) в запросах SQL. Чтобы упростить дело, в PDO
предоставляются вспомогательные средства, называемые подготовленными операторами.

Подготовленные операторы позволяют разделить выполнение запроса на две стадии. Сначала
методу prepare() из расширения PDO предоставляется вариант запроса со знаком ? в тех местах
запроса SQL, где требуется указать значения. Этот метод возвращает объект типа PDOStatement.
Затем для объекта типа PDOStatement вызывается метод execute(), которому передается массив
значений, подставляемых вместо замещающих знаков ?. Эти значения заключаются надлежащим
образом в кавычки перед вводом в запрос, чтобы защитить от атак типа умышленного внесения
запросов SQL. Безопасный вариант запроса SQL из примера 8.25 приведен в примере 8.26.
*/

Пример 8.26. Безопасный ввод данных из формы
$stmt = $db->prepare('INSERT INTO dishes (dish_name) VALUES (?)');
$stmt->execute(array($_POST['new_dish_name']));

/*
Заключать в кавычки замещающий знак в запросе не нужно, поскольку это делается в PDO
автоматически. Если же требуется указать в запросе несколько значений, соответствующее количе-
ство замещающих знаков следует ввести в запрос и массив значений. Так, в примере 8.27 приведен
запрос SQL с тремя замещающими знаками.
*/

Пример 8.27. Употребление нескольких замещающих знаков в запросе SQL
$stmt = $db->prepare('INSERT INTO dishes (dish_name, price, is_spicy)
VALUES (?,?,?)');
$stmt->execute(array($_POST['new_dish_name'], $_POST['new_price'], $_POST['is_spicy']));

/*
Законченная форма для ввода записей в базу данных
Все рассмотренные до сих пор особенности взаимодействия с базой данных сочетаются в примере
8.28 с кодом обработки форм из главы 7 для построения законченной программы, отображающей
форму, проверяющей достоверность переданных данных и затем сохраняющей данные в таблице
базы данных. В этой форме отображаются элементы ввода наименования блюда, цены на блюдо
и принадлежности его к блюдам со специями. Информация из переданной на обработку формы
вводится далее в таблицу dishes базы данных.
Исходный код из примера 8.28 основан на классе FormHelper, определенный в коде из примера
7.29. Чтобы не повторяться, в примере 8.28 предполагается, что исходный код этого класса сохранен
в файле FormHelper.php, который загружается в строке кода require ’FormHelper.php’,
находящейся в самом начале данной программы.
*/

// загрузить вспомогательный класс для составления форм
require 'FormHelper.php';
// подключиться к базе данных
try {
	$db = new PDO('mysql:host=localhost; dbname=test_db', 'root', '');
} catch (PDOException $e) {
	print "Can't connect: " . $e->getMessage();
	exit();
}
// установить исключения при ошибках в базе данных
$db->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
// Основная логика функционирования страницы:
// - Если форма передана на обработку, проверить достоверность
// данных, обработать их и снова отобразить форму.
// - Если форма не передана на обработку, отобразить ее снова
if ($_SERVER['REQUEST_METHOD'] == 'POST') {
// Если функция validate_form() возвратит ошибки,
// передать их функции show_form()
	list($errors, $input) = validate_form();
	if($errors) {
		show_form($errors);
	} else {
	// Переданные данные из формы достоверны, обработать их
		process_form($input);
	}
} else {
	// Данные из формы не переданы, отобразить ее снова
	show_form();
}


function show_form($errors = array()) {
	// установить свои значения по умолчанию:
	// цена составляет 5 долларов США
	$defaults = array('price' => '5.00');
	// создать объект $form с надлежащими свойствами по умолчанию
	$form = new FormHelper($defaults);
	// Ради ясности весь код HTML-разметки и отображения
	// формы вынесен в отдельный файл
	include 'insert-form.php';
}

function validate_form() {
	$input = array();
	$errors = array();
	// обязательное наименование блюда
	$input['dish_name'] = trim($_POST['dish_name'] ?? '');
	if (! strlen($input['dish_name'])) {
		$errors[] = 'Please enter the name of the dish.';
	}
	// цена должна быть указана достоверным положительным числом
	// с плавающей точкой
	$input['price'] = filter_input(INPUT_POST, 'price', FILTER_VALIDATE_FLOAT);
	if ($input['price'] <= 0) {
		$errors[] = 'Please enter a valid price.';
	}
	// по умолчанию в элементе ввода is_spicy устанавливается
	// значение 'no'
	$input['is_spicy'] = $_POST['is_spicy'] ?? 'no';
	return array($errors, $input);
}

function process_form($input) {
	// получить в этой функции доступ к глобальной переменной $db
	global $db;
	// установить в переменной $is_spicy значение в зависимости
	// от состояния одноименного флажка
	if ($input['is_spicy'] == 'yes') {
		$is_spicy = 1;
	} else {
		$is_spicy = 0;
	}
	// ввести новое блюдо в таблицу базы данных
	try {
		$stmt = $db->prepare('INSERT INTO dishes (dish_name, price, is_spicy) VALUES (?,?,?)');
		$stmt->execute(array($input['dish_name'], $input['price'], $is_spicy));
		// сообщить пользователю о вводе блюда в базу данных
		print 'Added ' . htmlentities($input['dish_name']) . ' to the database.';
		show_form();
	} catch (PDOException $e) {
		print "Couldn't add your dish to the database.";
	}
}

/*
Программа из примера 8.28 имеет такую же основную структуру, как и в примерах обработки
форм, приведенных в главе 7. Она состоит из функций для отображения, проверки достоверности,
обработки формы и некоторой глобальной логики, определяющей порядок вызова этих функций.
Новыми фрагментами в данной программе являются глобальный код, устанавливающий соединение
с базой данных, а также операции с базой данных в функции process_form().
Код, устанавливающий соединение с базой данных, следует после оператора require и перед
условным оператором if($_SERVER[’REQUEST_METHOD’]==’POST’). В операции new PDO()
устанавливается соединение с базой данных, а в ряде последующих строк кода сначала проверя-
ется, было ли подключение к базе данных произведено успешно, а затем устанавливается режим
исключения для обработки ошибок.

Функция show_form() отображает HTML-разметку формы из файла insert-form.php. Со-
держимое этого файла приведено в примере 8.29.
*/
?>
Пример 8.29. Форма для ввода записей в таблицу dishes базы данных

<form method="POST" action="<?= $form->encode($_SERVER['PHP_SELF']) ?>">
<table>
	<?php if ($errors) { ?>
	<tr>
		<td>You need to correct the following errors:</td>
		<td>
			<ul>
				<?php foreach ($errors as $error) { ?>
				<li><?= $form->encode($error) ?></li>
				<?php } ?>
			</ul>
		</td>
	<?php } ?>
	<tr>
		<td>Dish Name:</td>
		<td><?= $form->input('text', ['name' => 'dish_name']) ?></td>
	</tr>
	<tr>
		<td>Price:</td>
		<td><?= $form->input('text', ['name' => 'price']) ?></td>
	</tr>
	<tr>
		<td>Spicy:</td>
		<td><?= $form->input('checkbox',['name' => 'is_spicy', 'value' => 'yes']) ?> Yes</td>
	</tr>
	<tr>
		<td colspan="2" align="center"><?= $form->input('submit',['name' => 'save', 'value' => 'Order']) ?></td>
	</tr>
</table>
</form>

<?php

/*
Помимо подключения, все остальное взаимодействие с базой данных происходит в функции
process_form(). Сначала в строке кода global $db делается ссылка на переменную $db под-
ключения к базе данных вместо менее удобной ссылки на элемент глобального массива $GLOBALS
['db']. Столбец is_spicy таблицы dishes содержит значение 1 в строках с блюдами со специ-
ями и значение 0 в строках с блюдами без специй. Поэтому локальной переменной $is_spicy
присваивается далее подходящее значение в условном операторе if(), исходя из того, что было
передано в элементе глобального массива $input['is_spicy'].
После этого вызываются методы prepare() и execute(), которые фактически вводят новую
информацию в базу данных. Три замещающих знака в команде INSERT заполняются переменными
$input[’dish_name’], $input[’price’] и $is_spicy. Для столбца dish_id никакого зна-
чения указывать не нужно, поскольку он автоматически заполняется средствами самой программы
базы данных SQLite. И, наконец, в функции process_form() выводится сообщение, извещаю-
щее пользователя о вводе блюда в таблицу базы данных. А функция htmlentities() защищает
от появления любых дескрипторов HTML-разметки и элементов кода JavaScript в названии блюда.
Методы prepare() и execute() вызываются в блоке оператора try, и если что-нибудь в них
пойдет не так, то на экран будет выведено соответствующее сообщение об ошибке.
*/


Извлечение информации из базы данных

/*
PDO::query — Выполняет SQL-запрос и возвращает результирующий набор в виде объекта PDOStatement

public PDO::query ( string $statement ) : PDOStatement
public PDO::query ( string $statement , int $fetch_style = PDO::FETCH_COLUMN , int $colno ) : PDOStatement
public PDO::query ( string $statement , int $fetch_style = PDO::FETCH_CLASS , string $classname , array $ctorargs ) : PDOStatement
public PDO::query ( string $statement , int $fetch_style = PDO::FETCH_INTO , object $object ) : PDOStatement

PDO::query() выполняет SQL-запрос без подготовки и возвращает результирующий набор (если есть) в виде объекта PDOStatement.

Если запрос будет запускаться многократно, для улучшения производительности приложения имеет смысл этот запрос один раз подготовить 
методом PDO::prepare(), а затем запускать на выполнение методом PDOStatement::execute() столько раз, сколько потребуется.

Если после выполнения предыдущего запроса вы не выбрали все данные из результирующего набора, следующий вызов PDO::query() может 
потерпеть неудачу. В таких случаях следует вызывать метод PDOStatement::closeCursor(), который освободит ресурсы базы данных, занятые 
предыдущим объектом PDOStatement. После этого можно безопасно вызывать PDO::query().

Замечание:
Если передано более двух аргументов, то они будут обработаны, как если бы вы вызвали PDOStatement::setFetchMode() применительно к 
возвращаемому объекту.

Список параметров
statement
SQL-запрос для подготовки и выполнения.

Данные в запросе должны быть правильно экранированы.

Возвращаемые значения
PDO::query() возвращает объект PDOStatement или FALSE, если запрос выполнить не удалось.
*/

/*
Для извлечения информации из базы данных служит метод query(), которому передается за-
прос SQL для базы данных. Этот метод возвращает объект типа PDOStatement, предоставляющий
доступ к строкам, извлекаемым из таблицы базы данных. Всякий раз, когда для этого объекта
вызывается метод fetch(), по запросу из таблицы возвращается очередная строка. А если все
строки в таблице исчерпаны, то метод fetch() возвратит значение, которое вычисляется как лож-
ное (false), чем удобно воспользоваться в цикле while(), как показано в примере 8.30.
*/

Пример 8.30. Извлечение строк из таблицы с помощью методов query() и fetch()

$q = $db->query('SELECT dish_name, price FROM dishes');
while ($row = $q->fetch()) {
	print "$row[dish_name], $row[price] \n";
}

/*
На первом шаге цикла while() метод fetch() возвращает массив, содержащий значения
Walnut Bun and 1. Этот массив присваивается переменной $row. А поскольку непустой массив
вычисляется как истинный (true), то код в теле цикла while() продолжает выполняться, выводя
на экран данные из первой строки таблицы, возвращаемой по запросу с командой SELECT. И это
происходит еще три раза. На каждом шаге цикла while() метод fetch() возвращает очередную
строку из того ряда строк таблицы, которые возвращаются по запросу с командой SELECT. Когда же
все возвращаемые по запросу строки будут исчерпаны, метод fetch() возвратит значение, которое
вычисляется как ложное (false), и на этом цикл while() завершится.

PDOStatement::fetch
(PHP 5 >= 5.1.0, PHP 7, PECL pdo >= 0.1.0)

PDOStatement::fetch — Извлечение следующей строки из результирующего набора

fetch_style
Определяет, в каком виде следующая строка будет возвращена в вызывающий метод. 
Это может быть одна из констант PDO::FETCH_*. По умолчанию PDO::ATTR_DEFAULT_FETCH_MODE 
(что равносильно PDO::FETCH_BOTH).

PDO::FETCH_ASSOC: возвращает массив, индексированный именами столбцов результирующего набора

PDO::FETCH_BOTH (по умолчанию): возвращает массив, индексированный именами столбцов 
результирующего набора, а также их номерами (начиная с 0)

PDO::FETCH_BOUND: возвращает TRUE и присваивает значения столбцов результирующего набора 
переменным PHP, которые были привязаны к этим столбцам методом PDOStatement::bindColumn()

PDO::FETCH_CLASS: создает и возвращает объект запрошенного класса, присваивая значения 
столбцов результирующего набора именованным свойствам класса, и следом вызывает конструктор, 
если не задан PDO::FETCH_PROPS_LATE. Если fetch_style включает в себя атрибут PDO::FETCH_CLASSTYPE 
(например, PDO::FETCH_CLASS | PDO::FETCH_CLASSTYPE), то имя класса, от которого нужно создать объект, 
будет взято из первого столбца.

PDO::FETCH_INTO: обновляет существующий объект запрошенного класса, присваивая значения столбцов 
результирующего набора именованным свойствам объекта

PDO::FETCH_LAZY: комбинирует PDO::FETCH_BOTH и PDO::FETCH_OBJ, создавая новый объект со свойствами, 
соответствующими именам столбцов результирующего набора

PDO::FETCH_NAMED: возвращает массив такого же вида, как и PDO::FETCH_ASSOC, но, если есть несколько 
полей с одинаковым именем, то значением с этим ключом будет массив со всеми значениями из рядов, 
в которых это поле указано.

PDO::FETCH_NUM: возвращает массив, индексированный номерами столбцов (начиная с 0)

PDO::FETCH_OBJ: создает анонимный объект со свойствами, соответствующими именам столбцов результирующего набора

PDO::FETCH_PROPS_LATE: если используется с PDO::FETCH_CLASS, конструктор класса будет вызван перед назначением 
свойств из значений столбцов.

cursor_orientation
Для объектов PDOStatement представляющих прокручиваемый курсор, этот параметр определяет, какая строка будет 
возвращаться в вызывающий метод. Значением параметра должна быть одна из констант PDO::FETCH_ORI_*, 
по умолчанию PDO::FETCH_ORI_NEXT. Чтобы запросить прокручиваемый курсор для запроса PDOStatement, 
необходимо задать атрибут PDO::ATTR_CURSOR со значением PDO::CURSOR_SCROLL во время подготовки запроса 
методом PDO::prepare().

offset
Для объектов PDOStatement, представляющих прокручиваемый курсор, параметр cursor_orientation которых принимает 
значение PDO::FETCH_ORI_ABS, эта величина означает абсолютный номер строки, которую необходимо извлечь из 
результирующего набора.

Для объектов PDOStatement, представляющих прокручиваемый курсор, параметр cursor_orientation которых принимает 
значение PDO::FETCH_ORI_REL, эта величина указывает, какая строка относительно текущего положения курсора будет 
извлечена функцией PDOStatement::fetch().

Возвращаемые значения
В случае успешного выполнения функции возвращаемое значение зависит от режима выборки. В случае неудачи, функция 
всегда возвращает FALSE.


По умолчанию метод fetch() возвращает массив с числовыми и строковыми ключами. Начи-
ная с нуля, числовые ключи содержат значения из каждого столбца в строке. Аналогично имена
строковых ключей получают имена соответствующих столбцов таблицы. Так, в примере 8.30 те же
самые результаты можно было бы вывести на экран из элементов массива $row[0] и $row[1].
Если требуется выяснить, сколько строк таблицы возвращено по запросу с командой SELECT,
единственный надежный способ сделать это — извлечь из таблицы все нужные строки и подсчитать
их. Для этой цели объект типа PDOStatement предоставляет метод rowCount(), но он пригоден
не для всех баз данных. Если же в таблице имеется небольшое количество строк и все они должны
быть использованы в программе, то лучше воспользоваться методом fetchAll(), чтобы разместить
все строки таблицы в массиве, не прибегая к организации цикла, как показано в примере 8.31.

PDOStatement::fetchAll — Возвращает массив, содержащий все строки результирующего набора

Описание
public PDOStatement::fetchAll ([ int $fetch_style [, mixed $fetch_argument [, array $ctor_args = array() ]]] ) : array

Список параметров

fetch_style
Определяет содержимое возвращаемого массива. Подробней можно узнать из документации к методу PDOStatement::fetch(). 
По умолчанию параметр принимает значение PDO::ATTR_DEFAULT_FETCH_MODE (которое в свою очередь имеет умолчание PDO::FETCH_BOTH)

Чтобы извлечь значения только одного столбца, передайте в качестве значения этого параметра константу PDO::FETCH_COLUMN. 
С помощью параметра fetch_argument можно задать столбец, из которого требуется извлечь данные.

Если требуется извлечь только уникальные строки одного столбца, нужно передать побитовое ИЛИ констант PDO::FETCH_COLUMN и 
PDO::FETCH_UNIQUE.

Чтобы получить ассоциативный массив строк сгруппированный по значениям определенного столбца, нужно передать побитовое ИЛИ 
констант PDO::FETCH_COLUMN и PDO::FETCH_GROUP.

fetch_argument
Смысл этого аргумента зависит от значения параметра fetch_style:

PDO::FETCH_COLUMN: Будет возвращен указанный столбец. Индексация столбцов начинается с 0.

PDO::FETCH_CLASS: Будет создан и возвращен новый объект указанного класса. Свойствам объекта будут присвоены значения столбцов, 
имена которых совпадут с именами свойств.

PDO::FETCH_FUNC: Будут возвращены результаты вызовов указанной функции. Данные каждой строки результирующего набора будут передаваться 
в эту функцию.

ctor_args
Аргументы конструктора класса. Для случаев, когда параметру fetch_style присвоено значение PDO::FETCH_CLASS.

Возвращаемые значения
PDOStatement::fetchAll() возвращает массив, содержащий все оставшиеся строки результирующего набора. Массив представляет каждую строку 
либо в виде массива значений одного столбца, либо в виде объекта, имена свойств которого совпадают с именами столбцов.

Использование этого метода для извлечения строк больших результирующих наборов может пагубно сказаться на производительности системы и 
сетевых ресурсов. Вместо извлечения всех данных и их обработки в PHP рекомендуется использовать встроенные средства СУБД. Например, 
использование выражений WHERE и ORDER BY языка SQL может уменьшить размеры результирующего набора.

*/

Пример 8.31. Извлечение всех строк из таблицы без организации цикла
$q = $db->query('SELECT dish_name, price FROM dishes');
// Переменная $rows будет содержать четырехэлементный
// массив, в каждом элементе которого находится по одной
// строке, извлекаемой из таблицы базы данных
$rows = $q->fetchAll();

/*
Если же в таблице имеется столько строк, что извлекать их полностью непрактично, то про-
грамме базы данных можно направить запрос на автоматический подсчет строк с помощью функ-
ции COUNT() языка SQL. Например, по запросу SELECT COUNT(*) FROM dishes из таблицы
dishes возвратится одна строка с единственным столбцом, значение которого равно количеству
строк во всей таблице.
*/

Урок языка SQL: команда SELECT
/*
Команда SELECT извлекает информацию из таблицы базы данных. В примере 8.32 демонстрируется
синтаксис команды SELECT.
Пример 8.32. Извлечение информации из таблицы базы данных
SELECT столбец1[,столбец2, столбец3, ...] FROM имя_таблицы
По запросу с командой SELECT в примере 8.33 извлекаются столбцы dish_name и price из всех строк
таблицы dishes.
Пример 8.33. Извлечение столбцов dish_name и price
SELECT dish_name, price FROM dishes
Ради краткости вместо списка столбцов можно указать знак *. В этом случае из таблицы будут извлечены все
столбцы. Так, по запросу с командой SELECT в примере 8.34 из таблицы dishes извлекаются все столбцы.
Пример 8.34. Применение знака * в запросе SQL с командой SELECT
SELECT * FROM dishes
Чтобы ограничить выполнение команды SELECT извлечением только определенных строк из таблицы, эту
команду следует дополнить предложением WHERE. По запросу с командой SELECT из таблицы возвращаются
только те строки, которые соответствуют условию, указанному в предложении WHERE. Это предложение
указывается после имени таблицы, как показано в примере 8.35.
Пример 8.35. Ограничение, накладываемое на строки, возвращаемые из таблицы по запросу SQL с командой
SELECT
SELECT столбец1[, столбец2, столбец3, ...] FROM имя__таблицы WHERE
логическое_выражение
В той части запроса, где указано логическов_выражение, описываются строки, которые требуется извлечь
из таблицы. В примере 8.36 демонстрируется ряд запросов SQL с командой SELECT и предложением WHERE.
Пример 8.36. Извлечение определенных блюд из таблицы
; извлечь блюда по цене свыше 5.00
SELECT dish_name, price FROM dishes WHERE price > 5.00
; извлечь блюда, названия которых точно соответствуют "Walnut Bun"
SELECT price FROM dishes WHERE dish_name = 'Walnut Bun'
; извлечь блюда по цене свыше 5.00, но не больше 10.00
SELECT dish_name FROM dishes WHERE price > 5.00 AND price <= 10.00
; извлечь блюда по цене свыше 5.00, но не больше 10.00 или же
; блюда, названия которых точно соответствуют "Walnut Bun", но
; по любой цене
SELECT dish_name, price FROM dishes WHERE (price > 5.00 AND price <= 10.00)
OR dish_name = 'Walnut Bun'

В табл. 8.3 перечислены операции, которые можно употреблять в предложении WHERE.
Таблица 8.3. Операции, употребляемые в предложении WHERE запроса SQL
Операция Описание
= Равно (соответствует операции == в РНР)
<> Не равно (соответствует операции != в РНР)
> Больше
< Меньше
>= Больше или равно
<= Меньше или равно
AND Логическая операция И (соответствует операции && в РНР)
OR Логическая операция ИЛИ (соответствует операции || в РНР)
() Группирование

Если по запросу предполагается возвратить только одну строку из таблицы, вызовы методов
query() и fetch() можно связать в цепочку. Такой прием применяется в примере 8.37 для отоб-
ражения самого дешевого блюда в таблице dishes. Части ORDER BY и LIMIT запроса в данном
примере поясняются далее, во врезке “Урок языка SQL: предложения ORDER BY и LIMIT”.
*/

Пример 8.37. Извлечение строки из таблицы связыванием методов query() и fetch() в цепочку

$cheapest_dish_info = $db->query('SELECT dish_name, price FROM dishes ORDER BY price LIMIT 1')->fetch();
print "$cheapest_dish_info[0], $cheapest_dish_info[1]";

/*
Урок языка SQL: предложения ORDER BY и LIMIT
Как упоминалось ранее в разделе “Организация информации в базе данных”, строкам в таблице базы
данных не присущ какой-то определенный порядок расположения. Сервер базы данных не обязан
возвращать строки по запросу с командой SELECT в каком-то определенном порядке. Чтобы
возвратить строки из таблицы в нужном порядке, команду SELECT следует дополнить
предложением ORDER BY. Так, в примере 8.38 из таблицы dishes возвращаются все строки,
упорядоченные по цене: от самой низкой до самой высокой.
Пример 8.38. Упорядочение строк, возвращаемых по запросу с командой SELECT
SELECT dish_name FROM dishes ORDER BY price
Чтобы упорядочить строки по значению: от наибольшего до наименьшего, после имени столбца, по
которому происходит упорядочение, следует указать ключевое слово DESC (по убывающей). Так, в
примере 8.39 из таблицы dishes возвращаются все строки, упорядоченные по цене: от самой
высокой до самой низкой.
Пример 8.39. Упорядочение строк по цене: от самой высокой до самой низкой
SELECT dish_name FROM dishes ORDER BY price DESC

Для упорядочения можно указать несколько столбцов. Если же две строки содержат одинаковое
значение в первом столбце, указанном в предложении ORDER BY, они упорядочиваются по второму
столбцу. Так, строки, извлекаемые из таблицы dishes по запросу SQL из примера 8.40,
упорядочиваются по цене: от самой высокой до самой низкой. Если же в нескольких строках
окажется одинаковая цена, они упорядочиваются по имени в алфавитном порядке.
Пример 8.40. Упорядочение строк по нескольким столбцам
SELECT dish_name FROM dishes ORDER BY price DESC, dish_name
Употребление предложения ORDER BY в запросе SQL не изменяет порядок расположения строк в
самой таблице (напомним, что они не располагаются в каком- то определенном порядке), но
реорганизует результаты выполнения запроса. Это все равно, что дать кому-нибудь прочитать
закуски из ресторанного меню в алфавитном порядке. Это окажет влияние не на само напечатанное
меню, а на ответ по просьбе прочитать закуски в алфавитном порядке.
Как правило, по запросу SQL с командой SELECT возвращаются все строки, совпадающие с
условием в предложении WHERE, или же все строки таблицы, если в запросе отсутствует
предложение WHERE. Но иногда полезно получить в ответ определенный ряд строк, например,
найти самое дешевое блюдо в таблице или вывести лишь десять результатов поиска по запросу.
Чтобы ограничить результаты выполнения запроса конкретным количеством строк, в конце такого
запроса следует добавить предложение LIMIT. Так, по запросу SQL в примере 8.41 из таблицы
dishes возвращается строка с самым дешевым блюдом.

Пример 8.41. Ограничение количества строк, возвращаемых из таблицы по запросу SQL с командой
SELECT
SELECT * FROM dishes ORDER BY price LIMIT 1
А по запросу SQL в примере 8.42 из таблицы dishes возвращаются первые десять строк,
отсортированных по наименованиям блюд в алфавитном порядке.
Пример 8.42. Дополнительное количества строк, возвращаемых из таблицы по запросу SQL с
командой SELECT
SELECT dish_name, price FROM dishes ORDER BY dish_name LIMIT 10
В общем, в запросах SQL следует употреблять лишь предложение LIMIT, у которого также имеется
свое предложение ORDER BY. Если же опустить в запросе предложение ORDER BY, программа
базы данных может возвратить строки в любом порядке. Поэтому строка, обнаруженная первой при
выполнении запроса в первый раз, может таковой и не оказаться при выполнении того же самого
запроса в следующий раз.
*/

СТР 184

Изменение формата извлекаемых строк таблицы
/*
В приведенных до сих пор примерах метод fetch() возвращал строки из базы данных в ви-
де массивов, индексируемых как числами, так и символьными строками. С одной стороны, это
упрощает вставку значений в двойных кавычках, а с другой — может усложнить дело. Например,
трудно безошибочно запомнить, какому именно столбцу из запроса с командой SELECT соответству-
ет шестой элемент результирующего массива. Имена некоторых столбцов, возможно, потребуется
заключить в кавычки, чтобы вставить их надлежащим образом. А вынуждать интерпретатор РНР
устанавливать числовые и строковые индексы было бы расточительно, если они не требуются вместе.
Правда, расширение PDO позволяет указать предпочтительный способ доставки каждой результи-
рующей строки в отдельности. Для этого в качестве аргумента методу fetch() или fetchAll()
следует передать другой стиль извлечения, и тогда строка возвратится только в виде числового или
строкового массива или же в виде объекта.
Чтобы возвратить массив только с числовыми ключами, в качестве первого аргумента методу
fetch() или fetchAll() следует передать атрибут PDO::FETCH_NUM, а для того чтобы возвра-
тить массив только со строчными ключами — атрибут PDO::FETCH_ASSOC. Напомним, что массивы
со строковыми ключами иногда еще называют ассоциативными.
Чтобы возвратить объект вместо массива, в качестве первого аргумента упомянутым выше ме-
тодам следует передать атрибут PDO::FETCH_OBJ. Имена свойств объекта, возвращаемого для
каждой строки, соответствуют именам столбцов. Применение разных стилей извлечения демонстри-
руется в примере 8.43.
*/

Пример 8.43. Применение разных стилей извлечения

// При наличии только числовых индексов значения очень легко
// объединяются вместе
$q = $db->query('SELECT dish_name, price FROM dishes');
while ($row = $q->fetch(PDO::FETCH_NUM)) {
	print implode(', ', $row) . '<br>';
}


// При наличии объекта для получения значений используется
// синтаксис доступа к свойствам этого объекта
$q = $db->query('SELECT dish_name, price FROM dishes');
while ($row = $q->fetch(PDO::FETCH_OBJ)) {
	print "$row->dish_name has price $row->price" .'<br>';
}

/*
Если же стилем извлечения необходимо пользоваться неоднократно, его можно установить по
умолчанию для конкретной команды во всех запросах, отправляемых при конкретном подключе-
нии к базе данных. Чтобы установить стиль извлечения по умолчанию, достаточно вызвать метод
setFetchMode() для объекта типа PDOStatement, как показано в примере 8.44.
*/

Пример 8.44. Установка стиля извлечения по умолчанию для команды в запросе SQL
$q = $db->query('SELECT dish_name, price FROM dishes');
// Теперь методу fetch() не нужно больше ничего передавать,
// т.к. обо всем позаботится метод setFetchMode()
$q->setFetchMode(PDO::FETCH_NUM);
while($row = $q->fetch()) {
print implode(', ', $row) . "\n";
}

/*
Чтобы установить стиль извлечения по умолчанию для всех запросов, достаточно вызвать метод
setAttribute(), устанавливающий атрибут PDO::ATTR_DEFAULT_FETCH_MODE при подключе-
нии к базе данных:
*/
// Вызывать метод setFetchMode() или передавать что-нибудь
// методу fetch() не нужно, т.к. обо всем позаботится
// метод setAttribute()
$db->setAttribute(PDO::ATTR_DEFAULT_FETCH_MODE, PDO::FETCH_NUM);
$q = $db->query('SELECT dish_name, price FROM dishes');
while ($row = $q->fetch()) {
	print implode(', ', $row) . "\n";
}
$anotherQuery = $db->query(
'SELECT dish_name FROM dishes WHERE price < 5');
// Каждый подчиненный массив в многомерном массиве $moreDishes
// также проиндексирован числами
$moreDishes = $anotherQuery->fetchAll();


Безопасное извлечение данных для формы
/*
Замещающие знаки можно применять в команде SELECT таким же образом, как и в коман-
де INSERT, UPDATE или DELETE. Вместо того чтобы вызывать метод query() непосредственно,
можно вызвать методы prepare() и execute(), предоставив запрос с командой SELECT методу
prepare().
Но если данные из переданной на обработку формы или входные данные из внешнего источ-
ника указываются в предложении WHERE команды SELECT, UPDATE или DELETE, то необходимо
принять дополнительные меры для надлежащего экранирования любых подстановочных символов.
Рассмотрим в качестве примера форму поиска с текстовым элементом dish_search, где пользова-
тель может ввести наименование искомого блюда. При вызове метода execute() в коде из примера
8.45 используются замещающие знаки для защиты от смешивания одиночных кавычек в значении,
передаваемом на обработку.
*/

Пример 8.45. Применение замещающего знака в запросе SQL с командой SELECT
$stmt = $db->prepare('SELECT dish_name, price FROM dishes WHERE dish_name LIKE ?');
$stmt->execute(array($_POST['dish_search']));
while ($row = $stmt->fetch()) {
	// ... сделать что-нибудь с переменной $row ...
}

/*
Какое бы название блюда ни было введено в текстовом элементе dish_search, будь то Fried
Bean Curd или General Tso’s Chicken, замещающий знак позволяет надлежащим образом
вставить введенное название блюда в запрос SQL. Но, что если в текстовом элементе dish_search
введено название блюда %chicken%? В таком случае запрос SQL будет составлен следующим об-
разом:
SELECT dish_name, price FROM dishes WHERE dish_name LIKE '%chicken%'

Этому запросу соответствуют все строки таблицы, содержащие символьную строку "chicken",
а не только те строки, где значение в столбце dish_name точно равно %chicken%.
*/


Урок языка SQL: подстановочные символы
/*
Подстановочные символы удобны для неточного сопоставления текста, например, поиска
символьных строк, оканчивающихся на .edu или содержащих знак @. В языке имеются две
разновидности подстановочных символов: знак подчеркивания (_) для сопоставления с одним
символом и знак процента (%) для сопоставления с любым количеством символов (от нуля и больше).
В символьных строках подстановочные символы применяются вместе с оператором LIKE в
предложении WHERE. В примере 8.46 приведены два запроса SQL с командой SELECT, где
применяются подстановочные символы и оператор LIKE.

Пример 8.46. Применение подстановочных символов в запросах SQL с командой SELECT
; извлечь из таблицы все строки с наименованиями блюд,
; начинающихся с буквы D
SELECT * FROM dishes WHERE dish_name LIKE 'D%'
; извлечь из таблицы все строки с наименованиями блюд
; Fried Cod, Fried Bod, Fried Nod и т.д.
SELECT * FROM dishes WHERE dish_name LIKE 'Fried _od'
Подстановочные символы действуют и в предложениях WHERE, применяемых в командах UPDATE
и DELETE языка SQL. Так, в запросе SQL из примера 8.47 дублируются цены на все блюда со словом
chili (красный стручковый перец) в их наименовании.
Пример 8.47. Применение подстановочных символов в запросе SQL с командой UPDATE
UPDATE dishes SET price = price * 2 WHERE dish_name LIKE '%chili%'
В запросе SQL, приведенном в примере 8.48, из таблицы удаляются все строки, где наименования
блюд в столбце dish_name оканчиваются на Shrimp (Креветка).
Пример 8.48. Применение подстановочных символов в запросе SQL с командой DELETE
DELETE FROM dishes WHERE dish_name LIKE '%Shrimp'
Для сопоставления с самими знаками % и _ в операторе LIKE их следует предварить знаком
обратной косой черты. Так, по запросу SQL, приведенному в примере 8.49, обнаруживаются все
строки таблицы, где наименования блюд в столбце dish_name содержат фразу 50% off.
Пример 8.49. Экранирование подстановочных символов
SELECT * FROM dishes WHERE dish_name LIKE '%50\% off%'
В отсутствие обратной косой черты по запросу SQL из примера 8.49 были бы сопоставлены строки
таблицы, где наименования блюд в столбце dish_name содержат число 50, пробел и слово off в
любом сочетании, как, например, Spicy 50 shrimp with shells off salad (Салат из 50
креветок без раковин со специями) или Famous 500 offer duck (Утка, знаменитая
ассортиментом из 500 разных блюд).
*/


/*
Чтобы предотвратить действие подстановочных символов в запросах SQL, придется отказаться от
удобства и простоты замещающих знаков и положиться на следующие две функции: метод quote()
из расширения PDO и функцию strtr(), встроенную в РНР. Сначала следует вызвать метод
quote() для переданного на обработку значения.
Этот метод выполняет такую же операцию заключения в кавычки, как и замещающий знак. На-
пример, данный метод преобразует строковое значение General Tso’s Chicken в эквивалентное
значение ’General Tso”s Chicken’. Затем вызывается функция strtr(), чтобы экранировать
знаком обратной косой черты подстановочные символы % и _ в запросе SQL. Таким образом, за-
ключенное в кавычки и экранированное строковое значение может быть безопасно использовано в
запросе. В примере 8.50 показано, как с помощью метода quote() и функции strtr() переданное
на обработку значение делается безопасным для применения в предложении WHERE.
*/

/*
PDO::quote — Заключает строку в кавычки для использования в запросе

public PDO::quote ( string $string [, int $parameter_type = PDO::PARAM_STR ] ) : string

PDO::quote() заключает строку в кавычки (если требуется) и экранирует специальные символы 
внутри строки подходящим для драйвера способом.

Если вы используете эту функцию для построения SQL запросов, настоятельно рекомендуется 
пользоваться методом PDO::prepare() для подготовки запроса с псевдопеременными вместо и
спользования PDO::quote() для вставки данных введенных пользователем в SQL запрос. 
Подготавливаемые запросы с параметрами не только компактней, удобней, устойчивей к SQL-инъекции, 
но и работают быстрее, нежели вручную построенные запросы, так как клиент и сервер могут 
кешировать такие запросы в уже скомпилированном виде.

Не все драйверы PDO реализуют этот метод (особенно PDO_ODBC). Предполагается, что вместо него 
будут использоваться подготавливаемые запросы.

Предостережение
Безопасность: набор символов по умолчанию
Для корректной работы PDO::quote() набор символов должен быть задан либо на сервере, либо задаваться 
самим соединением с базой данных (это зависит от драйвера). Подробнее см. документацию к драйверу 
базы данных.


Список параметров
string
Экранируемая строка.

parameter_type
Представляет подсказку о типе данных первого параметра для драйверов, которые имеют альтернативные 
способы экранирования.

Возвращаемые значения
Возвращает экранированную строку, которую теоретически безопасно использовать в теле SQL запроса. 
Возвращает FALSE, если драйвер не поддерживает экранирование.
*/

/*
(PHP 4, PHP 5, PHP 7)

strtr — Преобразует заданные символы или заменяет подстроки
*/

strtr ( string $str , string $from , string $to ) : string
strtr ( string $str , array $replace_pairs ) : string

/*
Если указаны три аргумента, эта функция возвращает копию str, в которой все вхождения каждого символа 
(однобайтного) из from были заменены на соответствующий символ в параметре to, то есть каждое вхождение 
из $from[$n] заменяется на $to[$n], где $n - это корректное смещение строки в обоих аргументах.

Если длины строк from и to отличаются, "лишние" символы в более длинной строке не используются. Длина 
возвращаемого значения будет такой же, как и длина str.

strtr() может вызываться с двумя аргументами. В этом случае from должен быть массивом (array), в форме 
array('from' => 'to', ...). Функция возвратит строку, в которой все ключи массива будут заменены их 
элементами. strtr() в первую очередь заменяет более длинные ключи, причем одна и та же строка поиска 
используется только один раз.

В этом случае, ключи и значения могут иметь любую длину, за исключением того, что ключи не должны быть 
пустыми. Кроме того, длина возвращаемого значения может отличаться от str. Однако, стоит учесть тот факт, 
что эта функция максимально эффективна в том случае, если все ключи имеют одинаковый размер.

Список параметров
str  - Заменяемая строка (string).

from - Строка (string), которая будет заменена на строку to.

to - Строка (string), заменяющая строку from.

replace_pairs - Параметр replace_pairs может быть использован вместо to и from, в этом случае он является 
массивом (array) и имеет форму array('from' => 'to', ...).

Возвращаемые значения
Возвращает строку (string) с произведенными в ней заменами.

Если replace_pairs содержит ключ, являющийся пустой строкой (""), то будет возвращено значение FALSE. 
Если str не является скаляром, то он не преобразуется в строку. Вместо этого выдается предупреждение и 
возвращается NULL.

*/

Пример 8.50. Составление запроса SQL с командой SELECT без применения замещающих знаков
// Сначала заключть переданное на обработку значение в кавычки
$dish = $db->quote($_POST['dish_search']);
// Затем экранировать знаками обратной косой черты знаки
// подчеркивания и процента
$dish = strtr($dish, array=>('_' => '\_', '%' => '\%'));
// После санобработки значение переменной $dish может
// быть вставлено в запрос SQL
$stmt = $db->query("SELECT dish_name, price FROM dishes
WHERE dish_name LIKE $dish");


/*

В данном случае воспользоваться замещающим знаком нельзя, потому что экранирование под-
становочных знаков SQL выполняется после обычного заключения в кавычки, при котором знак
обратной косой черты ставится не только перед кавычками, но и перед самими знаками обратной
косой черты. Так, если обработать переданное строковое значение %chicken% сначала с помощью
функции strtr(), оно примет вид \%chicken\%. А после заключения в кавычки с помощью мето-
да quote() или замещающего знака оно примет вид '\\%chicken\\%'. Такое строковое значение
будет интерпретировано программой базы данных как знак обратной косой черты, после которого
следует подстановочный символ, обозначающий сопоставление с любыми символами, затем слово
chicken, далее еще один знак обратной косой черты и, наконец, еще один подстановочный символ
для сопоставления с любыми символами. Но если вызвать сначала метод quote(), то переданное
на обработку строковое значение %chicken% будет преобразовано в значение ’%chicken%’. А
в функции strtr() оно будет затем преобразовано в окончательный вид '\%chicken\%'. Такое
строковое значение будет интерпретировано программой базы данных как знак процентов, после
которого следует слово chicken и еще один знак процентов, т.е. именно в том виде, в каком это
значение было введено пользователем.
Если не заключить подстановочные символы в кавычки, это будет иметь еще более серьезные
последствия в предложении UPDATE или DELETE, применяемом в команде UPDATE или DELETE.
В примере 8.51 демонстрируется неверное применение знаков замещения в запросе SQL с целью
установить цену 1 доллар на блюда, определяемые значением, введенным пользователем.
*/