<?php

Пример 1.7. Отображение информации из базы данных
// использовать базу данных SQLite из файла 'dinner.db'
$db = new PDO('sqlite:dinner.db');
// определить, какие блюда имеются
$meals = array('breakfast','lunch','dinner');
// проверить, содержит ли параметр "meal" переданной
// на обработку формы одно из строковых значений
// "breakfast", "lunch" или "dinner"
if (in_array($_POST['meal'], $meals)) {
// Если данный параметр содержит указанное значение,
// получить все блюда для указанной трапезы
$stmt = $db->prepare('SELECT dish,price FROM meals
WHERE meal LIKE ?');
$stmt->execute(array($_POST['meal']));
$rows = $stmt->fetchAll();
// Если блюда в базе данных не обнаружены, сообщить от этом
if (count($rows) == 0) {
print "No dishes available.";
} else {
// вывести на экран каждое блюдо и цену на него
// в отдельной строке HTML-таблицы
print '<table><tr><th>Dish</th><th>Price</th></tr>';
foreach ($rows as $row) {
print "<tr><td>$row[0]</td><td>$row[1]</td></tr>";
}
print "</table>";
}
} else {
// Это сообщение выводится на экран в том случае,
// если параметр "meal" переданной на обработку формы
// не содержит ни одно из строковых значений
// "breakfast", "lunch" или "dinner"
print "Unknown meal.";
}




Глава 2. Обработка числовых и текстовых данных

// Функция trim() удаляет пробел в начале и в конце символьной строки. Этой функцией можно 
// воспользоваться в сочетании с функцией strlen(), возвращающей длину заданной строки, для 
// определения длины переданного значения, игнорируя начальные и конечные пробелы

Пример 2.3. Проверка длины усеченной символьной строки
// Переменная $_POST['zipcode'] содержит значение параметра
// "zipcode" из переданной на обработку формы
$zipcode = trim($_POST['zipcode']);
// А теперь это значение с удаленными начальными и конечными
// пробелами содержит переменная $zipcode
$zip_length = strlen($zipcode);
// выдать предупреждение, если указан почтовый индекс
// длиной меньше 5 символов
if ($zip_length != 5) {
print "Please enter a zip code that is 5 characters long.";
}

Пример 2.4. Более краткая форма проверки длины усеченной символьной строки
if (strlen(trim($_POST['zipcode'])) != 5) {
print "Please enter a zip code that is 5 characters long.";
}

Пример 2.5. Сравнение символьных строк с помощью операции равенства
if ($_POST['email'] == 'president@whitehouse.gov') {
print "Welcome, US President.";
}

//Чтобы сравнить символьные строки без учета регистра букв, следует воспользоваться функцией
strcasecmp();

//Если обе символьные строки, предоставляемые функции strcasecmp(), окажутся одинако-
//выми независимо от отличий в прописных и строчных буквах, она возвратит нулевое значение. В
//примере 2.6 показано, как пользоваться функцией strcasecmp().

Пример 2.6. Сравнение символьных строк без учета регистра
if (strcasecmp($_POST['email'], 'president@whitehouse.gov') == 0) {
print "Welcome back, OS President.";
}


//Функция printf() предоставляет более полный контроль над внешним видом выводимого ре-
//зультата по сравнению с оператором print.

Пример 2.7. Форматированный вывод цены с помощью функции printf()
$price = 5; $tax = 0.075;
printf('The dish costs $%.2f', $price * (1 + $tax));

//При выполнении приведенных выше строк кода на экран выводится следующий результат:
//The dish costs \$5.38

Пример 2.10. Смена регистра букв
print strtolower('Beef, CHICKEN, Pork, duCK'); //beef, chicken, pork, duck
print strtoupper('Beef, CHICKEN, Pork, duCK'); //BEEF, CHICKEN, PORK, DUCK

Пример 2.11. Выделение имен заглавными буквами с помощью функции ucwords()
print ucwords(strtolower('JOHN FRANKENHEIMER')); //John Frankenheimer

//С помощью функции substr() можно извлечь лишь часть символьной строки, например, для
//того, чтобы отображать начало сообщений на итоговой странице. В примере 2.12 демонстрируется
//применение функции substr() для усечения строкового значения параметра comments передава-
//емой на обработку формы.
Пример 2.12. Усечение символьной строки с помощью функции substr()

// Извлечь первые 30 байтов из строкового значения
// переменной $_POST['comments']
print substr($_POST['comments'], 0, 30);
// добавить многоточие
print '...';

//Если упомянутый выше параметр передаваемой на обработку формы содержит следующий ком-
//ментарий:
//The Fresh Fish with Rice Noodle was delicious,
//but I didn't like the Beef Tripe.
//то при выполнении кода из примера 2.12 на экран выводится такой результат:
//The Fresh Fish with Rice Noodle...

//Функция str_replace() заменяет отдельные части исходной символьной строки вместо то-
//го, чтобы извлекать из нее подстроку. С этой целью она находит подстроку и заменяет ее новой
//строкой. Это удобно для простой настройки HTML-разметки по шаблону. В примере 2.14 функция
//str_replace() применяется для установки атрибута class в дескрипторах <span>.

Пример 2.14. Применение функции str_replace()
$html = '<span class="class">Fried Bean Curd<span>
<span class="class">Oil-Soaked Fish</span>';
print str_replace('class', $my_class, $html);

Арифметические операции
// “плюс” (+) для обозначения операции сложения  
// “минус” (-) для операции вычитания
// знак косой черты (/) для операции деления
// знак “звездочка” (*) для операции умножения
//“две звездочки” (**), возведение в степень, внедрена в версии РНР 5.6. Если вы пользуетесь
//более ранней версией РНР, вызывайте функцию pow()
// знак процента (%) операции деления по модулю, в результате которой возвращается остаток от 
// деления, — : print 17 % 3;

Пример 2.17. Операции над переменными
$price = 3.95;
$tax_rate = 0.08;
$tax_amount = $price * $tax_rate;
$total_cost = $price + $tax_amount;

Пример 2.18. Сочетание операции присваивания с арифметической операцией
// прибавить число 3 обычным способом
$price = $price + 3;
// прибавить число 3 с помощью составной операции
$price += 3;


Пример 2.19. Сочетание операций присваивания и сцепления символьных строк
$username = 'james';
$domain = '@example.com';
// присоединить символьную строку из переменной $domain в
// конце строки из переменной $username обычным способом
$username = $username . $domain;
// сцепить символьные строки с помощью составной операции
$username .= $domain;

Пример 2.20. Инкрементирование и декрементирование
// прибавить 1 к значению переменной $birthday
$birthday = $birthday + 1;
// прибавить еще одну 1 к значению переменной $birthday
++$birthday;
// вычесть 1 из значения переменной $years_left
$years_left = $years_left - 1;
// вычесть еще одну 1 из значения переменной $years_left
--$years_left;

Пример 2.21. Вставка переменной
$email = 'jacob@example.com';
print "Send replies to: $email";

пример 2.22. //Вставка многих переменных в длинный блок (Встраиваемый документ)
//HTML-разметки
$page_title = 'Menu';
$meat = 'pork';
$vegetable = 'bean sprout';
print <<<MENU
<html>
<head><title>$page_title</title></head>
<body>
<ul>
<li> Barbecued $meat
<li> Sliced $meat
<li> Braised $meat with $vegetable </ul>
</body>
</html>
MENU;

/*
Встраиваемые и актуальные документы
В версии РНР 5.3 в дополнение к встраиваемому документу появился так называемый актуальный
документ. Если заключить начальный ограничитель в одиночные кавычки, то вместо встраиваемого
документа получится актуальный документ. В отличие от встраиваемого документа, в актуальный
нельзя вставлять переменные. Если встраиваемый документ можно представить, как многострочный
текст в двойных кавычках, то актуальный документ — как многострочный текст в одиночных
кавычках.
*/

Пример 2.23. Вставка переменной в фигурных скобках
$preparation = 'Braise';
$meat = 'Beef';
print "$preparationd $meat with Vegetables";

Пример 3.1. Принятие решения с помощью языковой конструкции if()

if ($logged_in) {
print "Welcome aboard, trusted user.";
}

Пример 3.2. Выполнение ряда операторов в блоке кода языковой конструкции if()
print "This is always printed.";
if ($logged_in) {
print "Welcome aboard, trusted user.";
print 'This is only printed if $logged_in is true.';
}
print "This is also always printed.";

//Чтобы выполнить другие операторы, если проверочное выражение в языковой конструкции if()
//оказывается ложным, оператор if() следует дополнить предложением else, как показано в при-
//мере 3.3.

Пример 3.3. Применение предложения else в условном операторе if()
if ($logged_in) {
print "Welcome aboard, trusted user.";
} else {
print "Howdy, stranger.";
}

Пример 3.4. Применение языковой конструкции elseif()
if ($logged_in) {
// Следующая строка кода выполняется, если проверочное
// условие $logged_in истинно
print "Welcome aboard, trusted user.";
} elseif ($new_messages) {
// Следующая строка кода выполняется, если проверочное
// условие $logged_in ложно, но проверочное условие
// $new_messages истинно
print "Dear stranger, there are new messages.";
} elseif ($emergency) {
// Следующая строка кода выполняется, если оба
// проверочных условия, $logged_in и $new_messages, ложны,
// но проверочное условие $emergency истинно
print "Stranger, there are no new messages,
but there is an emergency.";
}

Пример 3.5. Сочетание условных операторов else и elseif()
if ($logged_in) {
// Следующая строка кода выполняется, если проверочное
// условие $logged_in истинно
print "Welcome aboard, trusted user.";
} elseif ($new_messages) {
// Следующая строка кода выполняется, если проверочное
// условие $logged_in ложно, но проверочное условие
// $new_messages истинно
print "Dear stranger, there are new messages.";
} elseif ($emergency) {
// Следующая строка кода выполняется, если оба
// проверочных условия, $logged_in и $new_messages, ложны,
// но проверочное условие $emergency истинно
print "Stranger, there are no new messages,
but there is an emergency.";
} else {
// Следующая строка кода выполняется, если все проверочные
// условия, $logged_in, $new_messages и $emergency, ложны
print "I don't know you, you have no messages,
and there's no emergency.";
}

Пример 3.6. Операция сравнения на равенство
if ($new_messages == 10) {
print "You have ten new messages.";
}
if ($new_messages == $max_messages) {
print "You have the maximum number of messages.";
}
if ($dinner == 'Braised Scallops') {
print "Yum! I love seafood.";
}

Пример 3.7. Операция сравнения на неравенство
//В результате выполнения этой операции !=, возвращается 
//логическое значение true, если сравниваемые значения не равны,

if ($new_messages != 10) {
print "You don't have ten new messages.";
}
if ($dinner != 'Braised Scallops') {
print "I guess we're out of scallops.";
}

Пример 3.8. Операции сравнения на “меньше или равно” и “больше или равно”
if ($age > 17) {
print "You are old enough to download the movie.";
}
if ($age >= 65) {
print "You are old enough for a discount.";
}
if ($celsius_temp <= 0) {
print "Uh-oh, your pipes may freeze.";
}
if ($kelvin_temp < 20.3) {
print "Your hydrogen is a liquid or a solid now.";
}

/*Как уже упоминалось в разделе “Числа” главы 2, числа с плавающей точкой хранятся таким об-
разом, что их внутреннее представление может несколько отличаться от их присваиваемых значений.
Например, внутреннее представление сохраняемого числа 50.0 может быть равно 50.00000002.
Чтобы проверить на равенство два числа с плавающей точкой, следует сначала проверить, отлича-
ются ли оба числа меньше, чем на допустимую пороговую величину, вместо того, чтобы выполнять
операцию сравнения. Так, если сравниваются денежные суммы, то допустимой для них может быть
пороговая величина 0.00001. В примере 3.9 показано, каким образом сравниваются два числа с
плавающей точкой.
*/
Пример 3.9. Сравнение чисел с плавающей точкой
if(abs($price_1 - $price_2) < 0.00001) {
print '$price_1 and $price_2 are equal.';
} else {
print '$price_1 and $price_2 are not equal.';
}

Пример 3.11. Сравнение чисел и символьных строк
// Следующие значения сравниваются в лексикографическом порядке
if ("х54321"> "х5678") {
print 'The string "х54321" is greater than
the string "x5678".';
} else {
print 'The string "x54321" is not greater than
the string "x5678".';
}
// Следующие значения сравниваются в числовом порядке
if ("54321" > "5678") {
print 'The string "54321" is greater than
the string "5678".';
} else {
print 'The string "54321" is not greater than
the string "5678".';
}
// Следующие значения сравниваются в лексикографическом порядке
if ('6 pack' < '55 card stud') {
print 'The string "6 pack" is less than
the string "55 card stud".';
} else {
print 'The string "6 pack" is not less than
the string "55 card stud".';
}
// Следующие значения сравниваются в числовом порядке
if ('6 pack' < 55) {
print 'The string "6 pack" is less than the number 55.';
} else {
print 'The string "6 pack" is not less than the number 55.';
}
/*
Если требуется, чтобы интерпретатор РНР сравнивал символьные строки в лексикографическом
порядке, не преобразуя числа внутренним образом, воспользуйтесь функцией strcmp(). Она всегда
сравнивается свои аргументы в лексикографическом порядке.
*/
Пример 3.12. Сравнение символьных строк с помощью функции strcmp()
//strcmp — Бинарно-безопасное сравнение строк
strcmp ( string $str1 , string $str2 ) : int

/*Эта функция учитывает регистр символов.
Список параметров
str1
Первая строка.
str2
Вторая строка.
Возвращаемые значения
Возвращает отрицательное число, если str1 меньше str2, положительное число, если str1 больше str2, и 0, если строки равны.


strcasecmp() - Бинарно-безопасное сравнение строк без учета регистра
preg_match() - Выполняет проверку на соответствие регулярному выражению
substr_compare() - Бинарно-безопасное сравнение 2 строк со смещением, с учетом или без учета регистра
strncmp() - Бинарно-безопасное сравнение первых n символов строк
strstr() - Находит первое вхождение подстроки
substr() - Возвращает подстроку
*/

$х = strcmp("х54321","х5678");
if ($х > 0) {
print 'The string "х54321" is greater than the string "x5678".';
} elseif ($x < 0) {
print 'The string "x54321" is less than the string "x5678".';
}
$x = strcmp("54321","5678");
if ($x > 0) {
print 'The string "54321" is greater than the string "5678".';
} elseif ($x < 0) {
print 'The string "54321" is less than the string "5678".';
}
$х = strcmp('6 pack','55 card stud');
if ($x > 0) {
print 'The string "6 pack" is greater than
the string "55 card stud".';
} elseif ($x < 0) {
print 'The string "6 pack" is less than
the string "55 card stud".';
}
$x = strcmp('6 pack',55);
if ($x > 0) {
print 'The string "6 pack" is greater than the number 55.';
} elseif ($x < 0) {
print 'The string "6 pack" is less than the number 55.';
}


Пример 3.13. Сравнение разных типов данных с помощью составной операции типа
"космический корабль"
// Переменной $а присваивается отрицательное число,
// поскольку 1 меньше 12.7
$а = 1 <=> 12.7;
// Переменной $b присваивается положительное число,
// поскольку символ "c" следует после символа "b"
$b = "charlie" <=> "bob";
// Сравнение числовых символьных строк осуществляется аналогично
// операциям сравнения < и >, но не функции strcmp()
$х = '6 pack' <=> '55 card stud';
if ($x > 0) {
print 'The string "6 pack" is greater than
the string "55 card stud".';
} elseif ($x < 0) {
print 'The string "6 pack" is less than
the string "55 card stud".';
}
// Сравнение числовых символьных строк осуществляется аналогично
// операциям сравнения < и >, но не функции strcmp()
$х ='6 pack' <=> 55;
if ($х > 0) {
print 'The string "6 pack" is greater than the number 55.';
} elseif ($x < 0) {
print 'The string "6 pack" is less than the number 55.';
}

/*Для отрицания истинного значения служит операция !. Указание операции ! перед выражением
равнозначно проверке выражения на равенство логическому значению false. Так, условные опера-
торы if() в примере 3.14 равнозначны.
*/

Пример 3.14. Применение операции отрицания
// Все проверочное выражение ($finished == false)
// истинно, если значение переменной $finished равно false
if ($finished == false) {
print 'Not done yet!';
}
// Все проверочное выражение (! $finished) истинно,
// если значение переменной $finished равно false
if (! $finished) {
print 'Not done yet!';
}

Пример 3.15. Операция отрицания
if (! streaseemp($first_name, $last_name)) {
	//strcasecmp — Бинарно-безопасное сравнение строк без учета регистра
	//strcasecmp ( string $str1 , string $str2 )
	//Возвращает отрицательное число, если str1 меньше str2, положительное число,
	//если str1 больше str2, и 0, если строки равны.
print '$first_name and $last_name are equal.';
}

/*
Логические операции позволяют объединять несколько выражений в одном условном операторе
if(). В логической операции И (&&) проверяется, истинны ли оба объединяемых выражения. А в
логической операции ИЛИ (||) проверяется, является ли истинным хотя бы одно из объединяемых
выражений. Применение этих логических операций демонстрируется в примере 3.16.
*/

Пример 3.16. Логические операции
if (($age >= 13) && ($age < 65)) {
print "You are too old for a kid's discount and too
young for the senior's discount.";
}
if (($meal == 'breakfast') || ($dessert == 'souffle')) {
print "Time to eat some eggs.";
}

/*
Рекомендации относительно старшинства операций и употребления круглых скобок, приведенные
в главе 2, распространяются и на логические операции в проверочных выражениях. Во избежание
неоднозначности заключайте в круглые скобки подвыражения, составляющие более крупное прове-
рочное выражение.
*/

/*
Повторное выполнение операций в компьютерной программе называется организацией циклов.
Конструкция цикла while() аналогична повторению условного оператора if(). Как и в кон-
струкции if(), в конструкции цикла while() предоставляется проверочное выражение. Если это
выражение истинно, то блок кода выполняется. Но, в отличие от конструкции if(), выражение в
конструкции цикла while() проверяется снова после выполнения блока кода. Если проверочное
выражение по-прежнему истинно, блок кода выполняется снова, и так продолжается до тех пор, по-
ка данное выражение остается истинным. Но как только проверочное выражение окажется ложным,
выполнение программы будет продолжено со строк кода, следующих после блока кода, образующего
цикл. Нетрудно догадаться, что в блоке кода должно происходить нечто, оказывающее влияние на
проверочное выражение, чтобы цикл не продолжался бесконечно.
*/

Пример 3.17. Вывод на экран списка, размечаемого дескриптором <select>, в цикле, организу-
емом с помощью конструкции while()

$i = 1;
print '<select name="people">';
while ($i <= 10) {
print "<option>\$i</option>\n";
$i++;
}
print '</select>';

//свой пример
$i = 0;
while ( $i <= 9) {
	echo $i . '</br>';
	$i++;
}

/*
Простейшей формой цикла while является следующее выражение:
while (expr)
    statement
Смысл выражения while очень прост. Оно указывает PHP выполнять вложенные выражения повторно до тех пор, пока выражение в самом while является TRUE. Значение выражения expr проверяется каждый раз перед началом цикла, поэтому даже если значение выражения изменится в процессе выполнения вложенных выражений в цикле, выполнение не прекратится до конца итерации (каждый раз, когда PHP выполняет выражения в цикле - это одна итерация). В том случае, если выражение while равно FALSE с самого начала, вложенные выражения ни разу не будут выполнены.

Также, как и с оператором if, вы можете группировать несколько выражений внутри одного цикла while, заключая эти выражения между фигурными скобками или используя альтернативный синтаксис:

while (expr):
    statement
    ...
endwhile;
Следующие примеры идентичны, и оба выведут числа от 1 до 10:
*/

/* пример 1 */

$i = 1;
while ($i <= 10) {
    echo $i++;  /* выводиться будет значение переменной
                   $i перед её увеличением
                   (post-increment) */
}

/* пример 2 (устаревший) */

$i = 1;
while ($i <= 10):
    echo $i;
    $i++;
endwhile;


/*
Конструкция цикла for() также предоставляет возможность многократно выполнять одни и те
же операторы.

for (expr1; expr2; expr3)
    statement
Первое выражение (expr1) всегда вычисляется (выполняется) только один раз в начале цикла.

В начале каждой итерации оценивается выражение expr2. Если оно принимает значение TRUE, 
то цикл продолжается и выполняются вложенные операторы. Если оно принимает значение FALSE, 
выполнение цикла заканчивается.

В конце каждой итерации выражение expr3 вычисляется (выполняется).

Каждое из выражений может быть пустым или содержать несколько выражений, разделенных запятыми.
В expr2 все выражения, разделенные запятыми, вычисляются, но результат берется из последнего. 
Если выражение expr2 отсутствует, это означает, что цикл будет выполняться бесконечно. 
(PHP неявно воспринимает это значение как TRUE, так же, как в языке C). Это может быть не так бесполезно, 
как вы могли подумать, так как часто необходимо прервать цикл, используя условный оператор break вместо 
использования выражения в цикле for, которое принимает истинное значение.
*/

/* пример 1 */

for ($i = 1; $i <= 10; $i++) {
    echo $i;
}


/*
Массивы
Для создания массива следует воспользоваться языковой конструкцией array(), указав через запятую 
список пар “ключ-значение”, где ключ и значение разделяются знаками =>. Такой порядок
создания массивов демонстрируется в примере 4.1.
*/
Пример 4.1. Создание массивов
$vegetables = array(
	'corn' => 'yellow',
	'beet' => 'red',
	'carrot' => 'orange'
);
$dinner = array(
	0 => 'Sweet Corn and Asparagus',
	1 => 'Lemon Chicken',
	2 => 'Braised Bamboo Fungus'
);
$computers = array(
	'trs-80' => 'Radio Shack',
	2600 => 'Atari',
	'Adam' => 'Coleco'
);

/*Языковая конструкция array() сокращенно обозначается парой квадратных скобок, называе-
мой сокращенным синтаксисом массивов.
*/

Пример 4.2. Применение сокращенного синтаксиса массивов
$vegetables = [
	'corn'   => 'yellow', 
	'beet'   => 'red', 
	'carrot' => 'orange'
];
$dinner = [0 => 'Sweet Corn and Asparagus', 1 => 'Lemon Chicken', 2 => 'Braised Bamboo Fungus'];
$computers = ['trs-80' => 'Radio Shack', 2600 => 'Atari', 'Adam' => 'Coleco'];

//Сокращенный синтаксис массивов был внедрен в версии РНР 5.4. Если вы пользуетесь
//более ранней версией РНР, придерживайтесь языковой конструкции array().

/*
Элементы можно также вводить в массив по очереди, присваивая значение конкретному ключу
в массиве. Так, в примере 4.3 создаются те же самые массивы, что и в двух предыдущих примерах,
но теперь это делается поэлементно.
*/
Пример 4.3. Создание массива поэлементно
// Массив $vegetables со строковыми ключами
$vegetables['corn'] = 'yellow';
$vegetables['beet'] = 'red';
$vegetables['carrot') = 'orange';
// Массив $dinner с числовыми ключами
$dinner[0] = 'Sweet Corn and Asparagus';
$dinner[1] = 'Lemon Chicken';
$dinner[2] = 'Braised Bamboo Fungus';
// Массив $computers с числовыми и строковыми ключами
$computers['trs-80'] = 'Radio Shack';
$computers[2600] = 'Atari';
$computers['Adam'] = 'Coleco';
//В примере 4.3 квадратные скобки после имени переменной обозначают ссылку на конкретный
//ключ в массиве. Присвоив значение этому ключу, можно создать элемент в массиве.

Пример 4.4. Взаимное превращение скалярных и нескалярных величин
// Создание массива $vegetables
$vegetables['corn'] = 'yellow';
// Бесследное удаление строк "corn" и "yellow" и
// создание скалярной переменной $vegetables
$vegetables = 'delicious';
// Создание скалярной переменной $fruits
$fruits = 283;
// Не пройдет! Значение 283 по-прежнему остается в
// переменной $fruits, а интерпретатор РНР выдает предупреждение
$fruits['potassium'] = 'banana'; //Warning: Cannot use a scalar value as an array in ...
// А в данном случае содержимое переменной $fruits
// перезаписывается, и она становится массивом
$fruits = array('potassium' => 'banana');

/*
В языке РНР обеспечиваются сокращенные способы организации массивов, имеющих только
числа в качестве ключей. Так, если создать массив с помощью сокращенного синтаксиса [] или
конструкции array(), указав только список значений вместо пар “ключ-значение”, интерпретатор
РНР автоматически присвоит числовые ключи каждому значению в массиве. Ключи в таком мас-
сиве начинаются с нуля, возрастая по порядку с каждым новым элементом массива. Такой прием
демонстрируется в примере 4.5, где создается числовой массив $dinner.
*/

Пример 4.5. Создание числовых массивов с помощью языковой конструкции array()
$dinner = array(
	'Sweet Corn and Asparagus',
	'Lemon Chicken',
	'Braised Bamboo Fungus'
);
print "I want $dinner[0] and $dinner[1]";

/*Массивы только с числовыми ключами обычно называются числовыми,
индексированными или упорядоченными, а массивы со строковыми ключами — ассоциативными.
Иными словами, ассоциативный массив относится к тем видам массивов, ключи в которых обозна-
чают нечто иное, чем позиции значений в массиве. В данном случае каждый ключ ассоциируется
со своим значением.
Ключи в числовых массивах автоматически инкрементируются при создании самого массива или
вводе в него новых элементов с помощью сокращенного синтаксиса, как показано в примере 4.6.
*/

Пример 4.6. Ввод в массив новых элементов с помощью сокращенного синтаксиса
// Создать массив $lunch, состоящий из двух элементов.
// В следующей строке кода задается первый элемент
// массива $lunch[0]
$lunch[] = 'Dried Mushrooms in Brown Sauce';
// В следующей строке кода задается второй элемент
// массива $lunch[1]
$lunch[] = 'Pineapple and Yu Fungus';
// Создать массив $dinner, состоящий из трех элементов
$dinner = array(
	'Sweet Corn and Asparagus', 
	'Lemon Chicken',
	'Braised Bamboo Fungus'
);
// Ввести новый элемент в конце массива $dinner.
//В следующей строке кода задается четвертый элемент
// массива $dinner[3]
$dinner[] = 'Flank Skin with Spiced Flavor';

/*
При указании пустых квадратных скобок в массив вводится новый элемент, который получает
числовой ключ, на единицу больший самого большого числового ключа в массиве. Если же массив
еще не существует, то при указании пустых квадратных скобок вводится первый элемент нового
массива с нулевым ключом.
*/

//Определение размера массива
//Функция count() сообщает о количестве элементов в массиве.

Пример 4.7. Определение размера массива

$dinner = array(
	'Sweet Corn and Asparagus',
	'Lemon Chicken',
	'Braised Bamboo Fungus'
);
$dishes = count($dinner);
print "There are $dishes things for dinner.";

/*
Если передать функции count() пустой массив, т.е. такой массив, в котором отсутствуют эле-
менты, она возвратит нулевое значение. В проверочном выражении условного оператора if() пустой
массив определяется как ложный (false).

Перебор массивов

Обойти каждый элемент массива проще всего с помощью языковой конструкции foreach(),
которая позволяет выполнять блок кода для каждого элемента в массиве.
*/

Пример 4.8. Перебор массива с помощью языковой конструкции foreach()

$meal = array(
	'breakfast' => 'Walnut Bun',
	'lunch' => 'Cashew Nuts and White Mushrooms',
	'snack' => 'Dried Mulberries',
	'dinner' => 'Eggplant with Chili Sauce'
);
print "<table>\n";
foreach ($meal as $key => $value) {
print "<tr><td>$key</td><td>$value</td></tr>\n";
}
print '</table>';

/*
Сначала в цикле, организуемом с помощью языковой конструкции foreach(), ключ для каждого
 элемента массива $meal копируется в переменную $key, а значение — в переменную $value.
Затем выполняется код в фигурных скобках.

Для обозначения ключа и значения в блоке кода допускается выбирать какие угодно
имена переменных. Но если эти переменные употреблялись до языковой конструкции foreach(),
то они перезаписываются значениями из массива.
*/

Пример 4.9. Вывод HTML-таблицы с чередованием классов CSS

$row_styles = array(
	'even',
	'odd'
);
$style_index = 0;
$meal = array(
	'breakfast' => 'Walnut Bun',
	'lunch' 		=> 'Cashew Nuts and White Mushrooms',
	'snack' 		=> 'Dried Mulberries',
	'dinner' 		=> 'Eggplant with Chili Sauce'
);
print "<table>\n";
foreach ($meal as $key => $value) {
print '<tr class=' . $row_styles[$style_index] . '>';
print "<td>$key</td><td>$value</td></tr>\n";
// Смена значения переменной $style_index с 0 на 1, и обратно
$style_index = 1 - $style_index;
}
print '</table>';

/*
Изменение значений таких переменных цикла, как $key и $value, в блоке кода из языковой
конструкции foreach() не оказывает влияния на элементы в конкретном массиве. Если же тре-
буется изменить значения элементов массива, следует воспользоваться переменной $key в качестве
индекса. Именно такой прием применяется в примере 4.10 для удвоения значения каждого элемента
массива.
*/
Пример 4.10. Модификация массива с помощью языковой конструкции foreach()

$meals = array(
	'Walnut Bun' => 1,
	'Cashew Nuts and White Mushrooms' => 4.95,
	'Dried Mulberries' => 3.00,
	'Eggplant with Chili Sauce' => 6.50
);

foreach ($meals as $dish => $price) {
// выражение $price = $price * 2 HE пройдет!
$meals[$dish] = $meals[$dish] * 2;
}
// перебрать массив снова и вывести измененные
// значения его элементов
foreach ($meals as $dish => $price) {
printf("The new price of %s is \$%.2f.\n",$dish,$price);
}

Пример 4.11. Применение языковой конструкции foreach() для перебора числовых массивов

$dinner = array(
	'Sweet Corn and Asparagus',
	'Lemon Chicken',
	'Braised Bamboo Fungus');

foreach ($dinner as $dish) {
	print "You can eat: $dish\n";
}

/*
Применяя такую форму языковой конструкции foreach(), достаточно указать имя одной переменной
после предложения as, и тогда значение каждого элемента будет скопировано в эту переменную 
в блоке кода. Хотя ключи элементов недоступны в блоке кода.
Чтобы отслеживать текущее положение в массиве с помощью языковой конструкции foreach(),
придется воспользоваться отдельной переменной, инкрементируемой всякий раз, когда в цикле, 
организуемом с помощью данной конструкции, выполняется блок кода. Текущее положение в массиве
можно получить явным образом в переменной цикла с помощью языковой конструкции for(). Если 
в цикле, организуемом с помощью языковой конструкции foreach(), можно получить значение
каждого элемента массива, то в цикле, организуемом с помощью языковой конструкции for(), —
позицию каждого элемента в массиве. Организовать такой цикл, где можно было бы сразу получить
и то и другое, в РНР нельзя.
Так, если требуется выяснить текущее положение при переборе числового массива, следует 
воспользоваться языковой конструкцией for() вместо языковой конструкции foreach(). Цикл, 
организуемый с помощью языковой конструкции for(), должен зависеть от переменной цикла, значение
которой начинается с нуля и наращивается вплоть до величины, на единицу меньшей количества
элементов в массиве (пример 4.12).
*/

Пример 4.12. Перебор числового массива с помощью языковой конструкции for()

$dinner = array(
	'Sweet Corn and Asparagus',
	'Lemon Chicken',
	'Braised Bamboo Fungus'
);

for ($i = 0, $num_dishes = count($dinner); $i < $num_dishes; $i++) {
	print "Dish number $i is $dinner[$i]\n";
}

/*
При переборе массива в цикле, организуемом с помощью языковой конструкции for(), досту-
пен счетчик, обозначающий текущее положение в массиве. Над этим счетчиком можно выполнить
операцию взятия модуля (%), чтобы чередовать классы CSS в строках HTML-таблицы, как показано
в примере 4.13.
*/

Пример 4.13. Чередование классов CSS в строках HTML-таблицы с помощью языковой кон-
струкции for()

$row_styles = array('even', 'odd');
$dinner = array(
	'Sweet Corn and Asparagus',
	'Lemon Chicken',
	'Braised Bamboo Fungus'
);
print "<table>\n";
for ($i = 0, $num_dishes = count($dinner); $i < $num_dishes; $i++) {
	print '<tr class="' . $row_styles[$i % 2] . '">';
	print "<td>Element $i</td><td>$dinner[$i]</td></tr>\n";
}
print '</table>';

/*
При переборе массива с помощью языковой конструкции foreach() элементы массива будут
доступны в том порядке, в каком они были введены в массив: от первого и до последнего включи-
тельно. Если же имеется числовой массив, элементы которого введены не в том порядке, в каком
обычно следуют их ключи, то в конечном итоге могут быть получены неожиданные результаты. Так,
в примере 4.14 элементы массива выводятся на экран не в числовом и не в алфавитном порядке.
*/
Пример 4.14. Порядок вывода элементов массива в цикле, организуемом с помощью языковой
конструкции foreach()

$letters[0] = 'А';
$letters[1] = 'В';
$letters[3] = 'D';
$letters[2] = 'С';
foreach ($letters as $letter) {
	print $letter;
}

/*
Чтобы гарантировать доступ к элементам массива в числовом порядке следования их ключей,
достаточно перебрать массив в цикле, организуемом с помощью языковой конструкции for(), сле-
дующим образом:
*/
for ($i = 0, $num_letters = count($letters); $i < $num_letters; $i++) {
	print $letters[$i];
}

/*
Если требуется найти конкретный элемент в массиве, то для такого поиска придется пере-
брать целый массив. Имеются более эффективные способы обнаружения конкретного элемента.
Чтобы проверить элемент с помощью определенного ключа, следует воспользоваться функцией
array_key_exists(), как показано в примере 4.15. Эта функция возвращает логическое зна-
чение true, если элемент с предоставляемым ключом существует в искомом массиве.

array_key_exists — Проверяет, присутствует ли в массиве указанный ключ или индекс
array_key_exists ( mixed $key , array $array ) : bool
Функция array_key_exists() возвращает TRUE, если в массиве присутствует указанный ключ key. 
Параметр key может быть любым значением, которое подходит для индекса массива.
*/

Пример 4.15. Проверка наличия элемента в массиве по конкретному ключу
$meals = array(
	'Walnut Bun' => 1,
	'Cashew Nuts and White Mushrooms' => 4.95,
	'Dried Mulberries' => 3.00,
	'Eggplant with Chili Sauce' => 6.50,
	'Shrimp Puffs' => 0
	); // Shrimp Puffs are free!
$books = array(
	"The Eater's Guide to Chinese Characters",
	'How to Cook and Eat in Chinese'
);

// Следующая проверка дает истинное значение
if (array_key_exists('Shrimp Puffs',$meals)) {
print "Yes, we have Shrimp Puffs";
}
// Следующая проверка дает ложное значение
if (array_key_exists('Steak Sandwich',$meals)) {
print "We have a Steak Sandwich";
}
// Следующая проверка дает истинное значение
if (array_key_exists(1, $books)) {
print "Element 1 is How to Cook and Eat in Chinese";
}

/*
Чтобы проверить элемент с конкретным значением, следует воспользоваться функцией in_array()
in_array — Проверяет, присутствует ли в массиве значение
in_array ( mixed $needle , array $haystack [, bool $strict = FALSE ] ) : bool
Ищет в haystack значение needle. Если strict не установлен, то при поиске будет использовано нестрогое сравнение.
*/
(пример 4.16).
Пример 4.16. Проверка наличия в массиве элемента с конкретным значением
$meals = array(
	'Walnut Bun' => 1,
	'Cashew Nuts and White Mushrooms' => 4.95,
	'Dried Mulberries' => 3.00,
	'Eggplant with Chili Sauce' => 6.50,
	'Shrimp Puffs' => 0
);

$books = array(
	"The Eater's Guide to Chinese Characters",
	'How to Cook and Eat in Chinese'
);
// Следующая проверка дает истинное значение:
// по ключу Dried Mulberries в массиве имеется значение 3.00
if (in_array(3, $meals)) {
	print 'There is a $3 item.';
}
// Следующая проверка дает истинное значение
if (in_array('How to Cook and Eat in Chinese', $books)) {
	print "We have How to Cook and Eat in Chinese";
}
// Следующая проверка дает ложное значение:
// в функции in_array() учитывается регистр букв
if (in_array("the eater's guide to Chinese characters", $books)) {
	print "We have the Eater's Guide to Chinese Characters.";
}

/*
Функция in_array() возвращает логическое значение true, если обнаруживает в массиве эле-
мент с заданным значением. Сравнение символьных строк в этой функции выполняется с учетом
регистра букв. Функция array_search() действует аналогично функции in_array(), но она
возвращает ключ искомого элемента вместо логического значения true. Так, в примере 4.17 функ-
ция array_search() возвращает название блюда стоимостью 6,50 доллара.

array_search — Осуществляет поиск данного значения в массиве и возвращает ключ первого найденного
элемента в случае удачи
array_search ( mixed $needle , array $haystack [, bool $strict = FALSE ] ) : mixed
Ищет в haystack значение needle.
*/

Пример 4.17. Поиск элемента в массиве по конкретному значению
$meals = array(
	'Walnut Bun' => 1,
	'Cashew Nuts and White Mushrooms' => 4.95,
	'Dried Mulberries' => 3.00,
	'Eggplant with Chili Sauce' => 6.50,
	'Shrimp Puffs' => 0
);
$dish = array_search(6.50, $meals);
if ($dish) {
print "$dish costs \$6.50";
}

/*
Отдельными элементами массива можно оперировать, как и обычными скалярными переменны-
ми, применяя арифметические, логические и прочие операции.
*/

Пример 4.18. Оперирование элементами массива
$dishes = [];
$dishes['Beef Chow Foon'] = 12;
$dishes['Beef Chow Foon']++;
$dishes['Roast Duck'] = 3;
$dishes['total'] = $dishes['Beef Chow Foon'] + $dishes['Roast Duck'];
if ($dishes['total'] > 15) {
	print "You ate a lot: ";
}
print 'You ate ' . $dishes['Beef Chow Foon'] . ' dishes of Beef Chow Foon.';

/*
Вставка значений элементов, заключаемых в двойные кавычки, или встраиваемых документов
осуществляется аналогично вставке чисел и символьных строк. Вставить элемент массива проще
всего, введя его ключ в символьную строку, но не заключая этот ключ в кавычки
*/

Пример 4.19. Вставка элементов массива в символьные строки, заключаемые в двойные кавычки
$meals = [];
$meals['breakfast'] = 'Walnut Bun';
$meals['lunch'] = 'Eggplant with Chili Sauce';
$amounts = array(3, 6);
print "For breakfast, I'd like $meals[breakfast]
and for lunch,\n";
print "I'd like $meals[lunch]. I want $amounts[0]
at breakfast and\n";
print "$amounts[1] at lunch.";

/*
Вставка в примере 4.19 осуществляется только по ключам массива, состоящим исключительно
из букв, чисел и знаков подчеркивания. Если же в массиве имеется ключ, содержащий пробел или
знак препинания, то для вставки элемента массива по такому ключу последний следует заключить
в фигурные скобки, как в примере 4.20.
*/
Пример 4.20. Вставка элементов массива в символьные строки по ключам, заключаемым в
фигурные скобки
$meals['Walnut Bun'] = '$3.95';
$hosts['www.example.com'] = 'website';
print "A Walnut Bun costs {$meals['Walnut Bun']}.";
print "www.example.com is a {$hosts['www.example.com']}.";

/*
Чтобы удалить элемент из массива, достаточно вызвать функцию unset():
unset($dishes['Roast Duck']);
При удалении элемента с помощью функции unset() не просто устанавливается нулевое значение 
элемента или пустая символьная строка. После вызова функции unset() элемент отсутствует
в массиве, и его уже будет недоставать при обходе массива или подсчете количества его элементов.
Применить функцию unset() к массиву, где хранятся запасы товаров на складе, — это все равно, 
что сказать: данного товара на складе больше нет. А установить нулевое значение или пустую
строку в элементе массива — это все равно, что сказать: товара временно нет в наличии.

Если требуется вывести на экран значения сразу всех элементов массива, то для этого проще
всего вызвать функцию implode(). Эта функция формирует символьную строку, в которой объединяются 
все значения элементов массива, разделяемые заданным для строк ограничителем.

implode — Объединяет элементы массива в строку
implode ( string $glue , array $pieces ) : string
implode ( array $pieces ) : string
Объединяет элементы массива с помощью строки glue.
glue - По умолчанию равен пустой строке.
pieces - Массив объединяемых строк.
*/

$dimsum = array('Chicken Bun','Stuffed Duck Web','Turnip Cake');
$menu = implode(', ', $dimsum);
print $menu;

/*
Чтобы вывести весь массив без разделения его элементов заданным ограничителем, достаточно
указать пустую строку в качестве первого аргумента при вызове функции implode():
*/
$letters = array('А','В','С','D');
print implode('', $letters);

Пример 4.22. Вывод строк HTML-таблицы на экран с помощью функции implode()
$dimsum = array('Chicken Bun','Stuffed Duck Web','Turnip Cake');
print '<tr><td>' . implode ('</td><td>', $dimsum) . '</td></tr>';

/*
С функцией implode() сопряжена функция explode(), разбивающая символьную строку на
элементы массива. В качестве аргумента, обозначающего ограничитель, указывается подстрока, ко-
торую следует искать для разделения исходной строки на элементы массива. Применение функции
explode() демонстрируется в примере 4.23.

explode — Разбивает строку с помощью разделителя
explode ( string $delimiter , string $string [, int $limit = PHP_INT_MAX ] ) : array
Возвращает массив строк, полученных разбиением строки string с использованием delimiter в качестве 
разделителя.
delimiter - Разделитель.
string - Входная строка.
limit - Если аргумент limit является положительным, возвращаемый массив будет содержать максимум 
limit элементов, при этом последний элемент будет содержать остаток строки string.
Если параметр limit отрицателен, то будут возвращены все компоненты, кроме последних -limit.
Если limit равен нулю, то он расценивается как 1.
*/

Пример 4.23. Преобразование символьной строки в массив с помощью функции explode()
$fish = 'Bass, Carp, Pike, Flounder';
$fish_list = explode(', ', $fish);
print "The second fish is $fish_list[1]";

/*
Сортировка массивов
Массивы можно отсортировать несколькими способами. Выбор конкретной функции для сортировки 
массива зависит от требующегося порядка сортировки и типа массива.
Функция sort() сортирует массив по значениям его элемента. Ее можно применять только к
числовым массивам, поскольку в противном случае она сбрасывает исходные ключи в массиве по
ходу сортировки. Состояние массивов до и после сортировки с помощью функции sort() показано
в примере 4.24.
*/

Пример 4.24. Сортировка массива с помощью функции sort()
$dinner = array(
	'Sweet Corn and Asparagus',
	'Lemon Chicken',
	'Braised Bamboo Fungus'
);
$meal = array(
	'breakfast' => 'Walnut Bun',
	'lunch' => 'Cashew Nuts and White Mushrooms',
	'snack' => 'Dried Mulberries',
	'dinner' => 'Eggplant with Chili Sauce'
);

print "Before Sorting:";
foreach ($dinner as $key => $value) {
print " $dinner: $key $value";
}
foreach ($meal as $key => $value) {
print " $meal: $key $value";
}
sort($dinner);
sort($meal);

print "After Sorting:";
foreach ($dinner as $key => $value) {
print " $dinner: $key $value";
}
foreach $meal as $key => $value) {
print " \$meal: $key $value";
}

/*
Чтобы отсортировать ассоциативный массив по значениям его элементов, следует воспользоваться 
функцией asort(), которая сохраняет ключи вместе с их значениями. В примере 4.25 демонстрируется
сортировка массива $meal из примера 4.24 с помощью функции asort().
*/

Пример 4.25. Сортировка массива с помощью функции asort()
$meal = array(
	'breakfast' => 'Walnut Bun',
	'lunch' => 'Cashew Nuts and White Mushrooms',
	'snack' => 'Dried Mulberries',
	'dinner' => 'Eggplant with Chili Sauce'
);
print "Before Sorting:";
foreach ($meal as $key => $value) {
print " \$meal: $key $value";
}
asort($meal);

print "After Sorting:";
	foreach ($meal as $key => $value) {
print " \$meal: $key $value";
}

/*
В данном примере значения были отсортированы в массиве с помощью функции asort() таким
же образом, как и в предыдущем примере с помощью функции sort(). Но на этот раз ключи в
массиве сохранились в прежнем состоянии.
Если функции asort() и sort() сортируют массивы по значениям их элементов, то с помощью
функции ksort() их можно отсортировать по ключам. При этом пары “ключ-значение”
сохраняются вместе, но в то же время упорядочиваются по ключам. В примере 4.26 демонстрируется
сортировка массива $meal с помощью функции ksort().
*/

Пример 4.26. Сортировка массива с помощью функции ksort()
$meal = array(
	'breakfast' => 'Walnut Bun',
	'lunch' => 'Cashew Nuts and White Mushrooms',
	'snack' => 'Dried Mulberries',
	'dinner' => 'Eggplant with Chili Sauce'
);
print "Before Sorting:";
foreach ($meal as $key => $value) {
print " \$meal: $key $value";
}
ksort($meal);
print "After Sorting:";
foreach ($meal as $key => $value) {
print " \$meal: $key $value";
}

/*
У функций сортировки массивов sort(), asort() и ksort() имеются аналоги, сортирующие
массивы по убывающей и соответственно называемые rsort(), arsort() и krsort(). Они действуют 
аналогично функциям sort(), asort() и ksort(), но сортируют массив таким образом,
чтобы ключи или значения располагались в массиве по убывающей, начиная с самого большого 
(в алфавитном порядке) ключа или значения.
*/

Пример 4.27. Сортировка массива с помощью функции arsort()
$meal = array(
	'breakfast' => 'Walnut Bun',
	'lunch' => 'Cashew Nuts and White Mushrooms',
	'snack' => 'Dried Mulberries',
	'dinner' => 'Eggplant with Chili Sauce'
);
print "Before Sorting:";
	foreach ($meal as $key => $value) {
print " \$meal: $key $value";
}
arsort($meal);
print "After Sorting:";
	foreach ($meal as $key => $value) {
print " \$meal: $key $value";
}

/*
Функция arsort() сохраняет связь ключей со значениями в массиве аналогично функции
asort(), но она располагает элементы в противоположном (по значению) порядке. Теперь первым
в массиве оказывается элемент, строковое значение которого начинается с буквы W, а последним —
элемент, строковое значение которого начинается с буквы С.
*/

Пример 4.28. Создание многомерных массивов с помощью языковой конструкции array() или
сокращенного синтаксиса []
$meals = array(
	'breakfast' => ['Walnut Bun','Coffee'],
	'lunch' => ['Cashew Nuts', 'White Mushrooms'],
	'snack' => ['Dried Mulberries','Salted Sesame Crab']);

$lunches = [ 
	['Chicken','Eggplant','Rice'],
	['Beef','Scallions','Noodles'],
	['Eggplant','Tofu'] 
];

$flavors = array(
	'Japanese' => array(
		'hot' => 'wasabi',
		'salty' => 'soy sauce'
	),
	'Chinese' => array(
		'hot' => 'mustard',
		'pepper-salty' => 'prickly ash'
	)
);

/*
Для доступа к элементам в этих массивах массивов следует указать дополнительные квадратные
скобки, обозначающие отдельные элементы. Каждый ряд квадратных скобок обозначает один
уровень вхождения в массив. В примере 4.29 демонстрируется порядок доступа к элементам многомерных
массивов, определенных в примере 4.28.
*/

Пример 4.29. Доступ к элементам многомерного массива
print $meals['lunch'][1]; // White Mushrooms (Белые грибы)
print $meals['snack'][0]; // Dried Mulberries (Сушеная шелковица)
print $lunches[0][0]; // Chicken (Цыпленок)
print $lunches[2][1]; // Tofu (Соевый сыр)
print $flavors['Japanese']['salty']; // soy sauce (соевый соус)
print $flavors['Chinese']['hot']; // mustard (горчица)

/*
Каждый уровень в массиве называется его размерностью.
Такие массивы, как $meals, $lunches и $flavors, называются
многомерными, потому что каждый из них имеет больше одной размерности
*/

Пример 4.30. Манипулирование многомерными массивами
$prices['dinner']['Sweet Corn and Asparagus'] = 12.50;
$prices['lunch']['Cashew Nuts and White Mushrooms'] = 4.95;
$prices['dinner']['Braised Bamboo Fungus'] = 8.95;
$prices['dinner']['total'] =
$prices['dinner']['Sweet Corn and Asparagus'] +
$prices['dinner']['Braised Bamboo Fungus'];
$specials[0][0] = 'Chestnut Bun';
$specials[0][1] = 'Walnut Bun';
$specials[0][2] = 'Peanut Bun';
$specials[1][0] = 'Chestnut Salad';
$specials[1][1] = 'Walnut Salad';
// Если опустить индекс, новый элемент будет введен в конце массива.
// В следующей строке кода создается элемент массива $specials[1][2]
$specials[1][] = 'Peanut Salad';

/*
Для перебора многомерного массива по каждой его размерности следует организовать вложенные
циклы с помощью языковой конструкции foreach() или for(). Так, в примере 4.31 с помощью
языковой конструкции foreach() организуется вложенный цикл для перебора многомерного ассо-
циативного массива.
*/

Пример 4.31. Перебор многомерного массива во вложенном цикле, организованном с помощью
языковой конструкции foreach()

$flavors = array(
	'Japanese' => array(
		'hot' => 'wasabi',
		'salty' => 'soy sauce'
	),
	'Chinese' => array(
		'hot' => 'mustard',
		'pepper-salty' => 'prickly ash'
	)
);
// Переменная $culture содержит ключ, а переменная
// $culture_flavors - значение (в данном случае — массив)
foreach ($flavors as $culture => $culture_flavors) {
// Переменная $flavor содержит ключ, а переменная
// $example — значение
	foreach ($culture_flavors as $flavor => $example) {
		print "A $culture $flavor flavor is $example.";
	}
}

/*
Перебор многомерного числового массива во вложенном цикле, организуемом с помощью язы-
ковой конструкции for(), осуществляется таким же образом, как и во вложенном цикле, органи-
зуемом с помощью языковой конструкции foreach(). В примере 4.32 наглядно показано, как это
делается.
*/

Пример 4.32. Перебор многомерного массива во вложенном цикле, организуемом с помощью язы-
ковой конструкции for()

$specials = array( 
	array(
		'Chestnut Bun',
		'Walnut Bun',
		'Peanut Bun'
	),
	array(
		'Chestnut Salad',
		'Walnut Salad',
		'Peanut Salad'
	) 
);

// Переменная $num_specials содержит значение 2: количество
// элементов в первой размерности массива $specials

for ($i = 0, $num_specials = count($specials); $i < $num_specials; $i++) {
// Переменная $num_sub содержит значение 3: количество
// элементов в каждом подмассиве
	for ($m = 0, $num_sub = count($specials[$i]); $m < $num_sub; $m++) {
		print "Element [$i][$m] is " . $specials[$i][$m];
	}
}

/*
Во внешнем цикле, организуемом с помощью языковой конструкции for() в примере 4.32, перебираются 
два элемента массива $specials. А во внутреннем цикле, организуемом с помощью языковой 
конструкции for(), перебирается каждый элемент подмассивов, в которых хранятся разные символьные 
строки. В операторе print переменная $i служит индексом в первой размерности (элементов массива 
$specials), а переменная $m — индексом во второй размерности (подмассива). Чтобы вставить значение 
элемента многомерного массива в символьную строку, заключаемую в двойные кавычки, или во 
встраиваемый документ, следует воспользоваться синтаксисом фигурных скобок, как показано 
в примере 4.20. В примере 4.33 фигурные скобки применяются для вставки с целью получить такой же 
результат, как и в примере 4.32. На самом деле исходный код в примере 4.33 отличается от исходного 
кода в примере 4.32 единственной строкой с оператором print.
*/

Пример 4.33. Вставка значения элемента многомерного массива
$specials = array( 
	array(
		'Chestnut Bun',
		'Walnut Bun',
		'Peanut Bun'),
	array(
		'Chestnut Salad',
		'Walnut Salad',
		'Peanut Salad'
	) 
);
// Переменная $num_specials содержит значение 2: количество
// элементов в первой размерности массива $specials
for ($i = 0, $num_specials = count($specials); $i < $num_specials; $i++) {
	// Переменная $num_sub содержит значение 3: количество
	// элементов в каждом подмассиве
	for ($m = 0, $num_sub = count($specials[$i]); $m < $num_sub; $m++) {
		print "Element [$i][$m] is $specials[$i][$m]";
	}
}


//Функции

/*
Интерпретатор РНР трактует одну переменную $name в
самой функции и другую переменную $name за ее пределами как две не связанные вместе перемен-
ные.


Объявление и вызов функций

Для создания новой функции служит ключевое слово function, после которого следует имя
функция и ее тело, заключаемое в фигурные скобки. Так, в примере 5.1 объявляется функция
page_header().1
*/

Пример 5.1. Объявление функции
function page_header() {
	print '<html><head><title>Welcome to my site</title></head>';
	print '<body bgcolor="#ffffff">';
}

/*
Функции именуются по тем же правилам, что и переменные. Их имена должны начинаться с
буквы или знака подчеркивания, а остальными символами в имени функции могут быть буквы, числа
и знаки подчеркивания. И хотя интерпретатор РНР не препятствует употреблению в программе
переменной и функции с одинаковым именем, этого следует всячески избегать, поскольку наличие
многих элементов с одинаковыми именами в программе затрудняет ее понимание.
*/

Пример 5.2. Вызов функции
page_header();
print "Welcome, $user";
print "</body></html>";

/*
Функции можно определять до и после их вызова. Интерпретатор РНР читает весь файл программы
и выявляет в нем определения всех функций, прежде чем выполнять любые команды из этого файла. 
Обе функции, page_header() и page_footer(), благополучно выполняются в коде из примера 5.3, 
несмотря на то, что функция page_header() объявлена до ее вызова, а функция page_footer() — после.
*/

Пример 5.3. Объявление функций до и после их вызова
function page_header() {
	print '<html><head><title>Welcome to my site</title></head>';
	print '<body bgcolor="#ffffff">';
}
page_header();
print "Welcome, $user";
page_footer();
function page_footer() {
	print '<hr>Thanks for visiting.';
	print ' </body></html>';
}

/*
Передача аргументов функциям
Если одни функции (например, функция page_header() из предыдущего раздела) всегда выполняют 
одни и те же действия, то другие оперируют входными значениями, которые могут изменяться. 
Входные значения, предоставляемые функции, называются аргументами. Аргументы повышают 
эффективность функций, поскольку делают их более гибкими. Функцию page_header() можно 
видоизменить, чтобы она принимала цвет страницы в качестве аргумента. Видоизмененное
объявление этой функции приведено в примере 5.4.
*/

Пример 5.4. Объявление функции с одним аргументом
function page_header2($color) {
	print '<html><head><title>Welcome to my site</title></head>';
	print '<body bgcolor="#' . $color . '">';
}

/*
В объявлении приведенной выше функции введена переменная $color, заключаемая в круглые 
скобки после имени функции. Благодаря этому в коде, составляющем тело данной функции,
можно воспользоваться переменной $color, хранящей значение, передаваемое функции в качестве
аргумента при ее вызове. Эту функцию можно, например, вызвать следующим образом:
*/
page_header2('сс00сс');

/*
Если объявить функцию, принимающую аргумент, как демонстрируется в примере 5.4, то при
ее вызове следует непременно передать ей аргумент. Если же вызвать такую функцию, не указав
значение в качестве ее аргумента, интерпретатор РНР выдаст предупреждение об отсутствии 
обязательного аргумента в вызове функции.

Во избежание подобного предупреждения функцию можно определить таким образом, чтобы она
принимала необязательный аргумент, указав значение этого аргумента по умолчанию в объявлении
функции. Если при вызове такой функции предоставляется значение аргумента, то в ее теле 
используется именно это значение. А если такое значение не предоставлено при вызове функции, 
то в ее теле используется значение, устанавливаемое по умолчанию при ее объявлении. 
Так, в примере 5.5 по умолчанию устанавливается значение сс3399 переменной $color, которое 
передается объявляемой функции в качестве аргумента.
*/

Пример 5.5. Указание значения аргумента функции, устанавливаемого по умолчанию
function page_header3($color = 'сс3399') {
	print '<html><head><title>Welcome to my site</title></head>';
	print '<body bgcolor="#' . $color . '">';
}
/*
Значения аргументов по умолчанию должны задаваться лишь как литералы, например: 12,
сс3399 или Shredded Swiss Chard. Их нельзя задавать как переменные. Так, приведенная
ниже функция объявлена неверно, и поэтому при ее вызове механизм РНР аварийно завершит
выполнение программы.
*/
$my_color = '#000000';
// Эта функция объявлена неверно, так как значение по умолчанию
// не может быть задано как переменная
function page_header_bad($color = $my_color) {
print '<html><head><title>Welcome to my site</title></head>';
print '<body bgcolor="#' . $color . '">';
}

/*Чтобы определить функцию, принимающую несколько аргументов, их следует указать списком
через запятую в объявлении функции. Так, в примере 5.6 объявляется функция page_header4(),
принимающая два аргумента: $color и $title.
*/
Пример 5.6. Объявление функции с двумя аргументами
function page_header4($color, $title) {
	print '<html><head><title>
	Welcome to ' . $title . '</title></head>';
	print '<body bgcolor="#' . $color . '">';
}
/*
Чтобы передать функции несколько аргументов при ее вызове, их следует указать тем же самым
списком через запятую. Так, в примере 5.7 функция page_header4() вызывается со значениями
переменных $color и $title в качестве аргументов.
*/

page_header4('66сс66','my homepage');

/*
В примере 5.8 оба аргумента являются обязательными. Аналогичный синтаксис можно употреблять 
и в функциях, принимающих несколько аргументов, чтобы обозначить значения аргументов по
умолчанию, как это обычно делается в объявлениях функций, принимающих единственный аргумент. 
Но все необязательные аргументы должны следовать после любых обязательных аргументов.
В примере 5.6 демонстрируются верные способы объявления функций, принимающих три аргумента,
один, два или три из которых являются необязательными.
*/

Пример 5.8. Объявление функций с несколькими необязательными аргументами
// Объявление функции с одним необязательным аргументом,
// который должен быть указан последним
function page_header5($color, $title, $header = 'Welcome') {
print '<html><head><title>
Welcome to ' . $title . '</title></head>';
print '<body bgcolor="#' . $color . '">';
print "<h1>$header</h1>";
}

// Допустимые способы вызова данной функции:
page_header5('66сс99','my wonderful page');
// В этом вызове используется значение аргумента $header,
// устанавливаемое по умолчанию
page_header5('66сс99','my wonderful page','This page is great!');
// В этом вызове значение по умолчанию не используется

// Объявление функции с двумя необязательными аргументами,
// которые должны быть указаны последними
function page_header6($color, $title = 'the page', $header = 'Welcome') {
	print '<html><head><title>
	Welcome to ' . $title . '</title></head>';
	print '<body bgcolor="#' . $color . '">';
	print "<h1>$header</h1>";
}
// Допустимые способы вызова данной функции:
page_header6('66сс99'); // В этом вызове используются значения
// аргументов $title и $header, устанавливаемые по умолчанию
page_header6('66сс99','my wonderful page');
// В этом вызове используется значение аргумента $header,
// устанавливаемое по умолчанию
page_header6('66сс99','my wonderful page','This page is great!');
// В этом вызове значения по умолчанию не используются


// Объявление функции со всеми тремя необязательными аргументами
function page_header7($color = '336699', $title = 'the page', $header = 'Welcome') {
print '<html><head><title>
Welcome to ' . $title . '</title></head>';
print '<body bgcolor="#' . $color . '">';
print "<h1>$header</h1>";
}
// Допустимые способы вызова данной функции:
page_header7(); // В этом вызове используются значения всех
// аргументов, устанавливаемые по умолчанию
page_header7('66сс99'); // В этом вызове используются значения
// аргументов $title и $header, устанавливаемые по умолчанию
page_header7('66сс99', 'my wonderful page'); // В этом вызове
// используется значение аргумента $header,
// устанавливаемое по умолчанию
page_header7('66сс99','my wonderful page','This page is great!');
// В этом вызове значения по умолчанию не используются

/*
\Все необязательные аргументы должны быть указаны в конце списка аргументов функции во
избежание неоднозначности их интерпретации. Так, если определить функцию page_header7()
с первым обязательным аргументом $color, вторым необязательным аргументом $title и третьим 
обязательным аргументом $header, то что будет означать вызов page_header7('33сс66',
'Good Morning')? Ведь аргумент 'Good Morning' может быть значением переменной $title
или $header. Этого недоразумения можно избежать, указав все необязательные аргументы после
любых обязательных аргументов.

Любые изменения, вносимые в переменную, передаваемую функции в качестве аргумента, не
оказывают влияния на саму переменную за пределами функции2. Так, в примере 5.9 значение 
переменной $counter за переделами вызываемой функции не изменяется.
*/

Пример 5.9. Изменение значений аргументов в функции
function countdown($top) {
	while ($top > 0) {
		print "$top..";
		$top--;
	}
	print "boom!";
}
$counter = 5;
countdown($counter);
print "Now, counter is $counter";

/*
Передача переменной $counter в качестве аргумента функции countdown() указывает интерпретатору 
РНР на необходимость скопировать значение переменной $counter в переменную $top
в начале выполнения функции, поскольку именем $top обозначен аргумент данной функции. Все,
что происходит с переменной $top в теле функции, не оказывает никакого влияния на переменную
$counter. Как только значение переменной $counter будет скопировано в переменную $top,
переменная $counter останется незатронутой в процессе выполнения функции.
Видоизменение аргументов не оказывает влияния на переменные за переделами функции, даже
если аргумент имеет такое же имя, как и внешняя переменная. Если изменить функцию countdown()
в примере 5.9 таким образом, чтобы ее аргумент назывался $counter, а не $top, то значение внешней 
переменной $counter все равно не изменится. В данном случае аргумент и внешняя переменная
просто называются одинаково, но никак не связаны вместе.
*/


/*
Возврат значений из функций
Функция вывода на экран заголовка веб-страницы, рассмотренная ранее в этой главе, предпри-
нимает определенное действие, отображая результат. Помимо таких действий, как вывод данных
или сохранение информации в базе данных, функции способны также вычислять значение, назы-
ваемое возвращаемым и применяемое далее в программе. Чтобы возвратить значение из функции,
результат ее вызова следует присвоить переменной. Так, в примере 5.10 значение, возвращаемое
встроенной функцией number_format(), сохраняется в переменной $number_to_display.
*/

Пример 5.10. Сохранение значения, возвращаемого функцией
$number_to_display = number_format(321442019);
print "The population of the US is about: $number_to_display";

/*
Чтобы возвратить значения из создаваемых функций, следует воспользоваться ключевым словом
return, указав после него возвращаемое значение. Как только выполнение функции дойдет до
оператора return, оно остановится и будет возвращено значение, связанное с этим оператором. В
примере 5.11 определяется функция, возвращающая общую сумму в ресторанном счете с учетом
налога на добавленную стоимость и чаевых.
*/

Пример 5.11. Возврат значения из функции
function restaurant_check($meal, $tax, $tip) {
	$tax_amount = $meal * ($tax / 100);
	$tip_amount = $meal * ($tip / 100);
	$total_amount = $meal + $tax_amount + $tip_amount;
	return $total_amount;
}

/*
Значением, возвращаемым функцией restaurant_check(), можно воспользоваться таким же
образом, как и любым другим значением в программе
*/

Пример 5.12. Применение возвращаемого значения в условном операторе if()
// Рассчитать общую стоимость трапезы на 15,22 долларов США
// с учетом налога на добавленную стоимость (8.25%) и чаевых (15%)
$total = restaurant_check(15.22, 8.25, 15);
print 'I only have $20 in cash, so...';
if ($total > 20) {
	print "I must pay with my credit card.";
} else {
	print "I can pay with cash.";
}

/*
В отдельном операторе return из функции можно возвратить только одно значение, но не
несколько. Оператор вроде return 15, 23 в РНР недопустим. Если же требуется возвратить
несколько значений из функции, их следует сначала разместить в массиве, а затем возвратить
массив.
В примере 5.13 приведен видоизмененный вариант функции restaurant.check(), возвращающей 
двухэлементный массив, содержащий общую сумму как без учета, так и с учетом налога на
добавленную стоимость и чаевых.
*/

Пример 5.13. Возврат массива из функции
function restaurant_check2($meal, $tax, $tip) {
	$tax_amount = $meal * ($tax / 100);
	$tip_amount = $meal * ($tip / 100);
	$total_notip = $meal + $tax_amount;
	$total_tip = $meal + $tax_amount + $tip_amount;
	return array($total_notip, $total_tip);
}

Пример 5.14. Применение массива, возвращаемого функцией
$totals = restaurant_check2(15.22, 8.25, 15);
if ($totals[0] < 20) {
	print 'The total without tip is less than $20.';
}
if ($totals[1] < 20) {
	print 'The total with tip is less than $20.';
}

/*
Несмотря на то что в одном операторе return допускается возвращать только одно значение из
функции, в ее теле можно употребить несколько подобных операторов. Первый же оператор return,
достигнутый в ходе выполнения функции, остановит ее выполнение и возвратит из нее значение. В
примере 5.15 логика определения способа оплаты ресторанного счета вынесена из примера 5.12 в
новую функцию, где выясняется один из двух способов оплаты: наличными или кредитной карточкой.
*/

Пример 5.15. Применение нескольких операторов return в функции
function payment_method($cash_on_hand, $amount) {
	if ($amount > $cash_on_hand) {
		return 'credit card';
	} else {
		return 'cash';
	}
}

/*
Новая функция payment_method() применяется в примере 5.16, где ей передается результат
выполнения функции restaurant_check().
*/
Пример 5.16. Передача возвращаемого значения другой функции
$total = restaurant_check(15.22, 8.25, 15);
$method = payment_method(20, $total);
print 'I will pay with ' . $method;

/*
Такой результат получается потому, что общая сумма, возвращаемая функцией restaurant_check(), 
меньше 20. Эта сумма передается далее функции payment_method() в качестве аргумента $total. 
Первое же сравнение переменных $amount и $cash_on_hand в теле функции payment_method() 
дает логическое значение false, поэтому далее выполняется блок кода в условном операторе else. 
В итоге функция payment_method() возвращает строковое значение cash.
Правила обработки логических значений truth и else, обсуждавшиеся в главе 3, распространяются 
и на функции. Эти правила позволяют выгодно применять функции в условных операторах
if() и других языковых конструкциях, управляющих ходом выполнения программы. Так, в примере 
5.17 решение о том, что делать дальше, принимается на основании значения, возвращаемого в
результате вызова функции restaurant_check() в проверочном выражении условного оператора if().
*/

Пример 5.17. Применение возвращаемых значений в условном операторе if()
if (restaurant_check(15.22, 8.25, 15) < 20) {
	print 'Less than $20, I can pay cash.';
} else {
	print 'Too expensive, I need my credit card.';
}

/*
Чтобы вычислить проверочное выражение в коде из примера 5.17, интерпретатор РНР сначала
вызывает функцию restaurant_check(). Значение, возвращаемое этой функцией, затем сравнивается 
с заданным значением 20, как будто это значение переменной или литерала. Если функция
restaurant_check() возвращает число меньше 20, как в данном примере, то выполняется первый 
оператор print. В противном случае выполняется второй оператор print.

Проверочное выражение может также состоять из одного только вызова функции без сравнения
или иной операции. В таком проверочном выражении значение, возвращаемое функцией, преобразуется 
в логическое значение true или false по правилам, разъясненным в разделе “Общее
представление об истинности или ложности” главы 3. Если из функции возвращается логическое
значение true, то проверочное выражение оказывается истинным. А если из функции возвращается 
логическое значение false, то проверочное выражение оказывается ложным. Кроме того, из
функции можно явным образом возвратить логическое значение true или false, чтобы сделать
более очевидным ее применение в проверочном выражении. Именно так и делается в функции
can_pay_cash() из примера 5.18, где определяется способ оплаты за трапезу в ресторане.
*/

Пример 5.18. Возврат логического значения true или false из функции
function can_pay_cash($cash_on_hand, $amount) {
	if ($amount > $cash_on_hand) {
		return false;
	} else {
		return true;
	}
}
$total = restaurant_check(15.22,8.25,15);
if (can_pay_cash(20, $total)) {
	print "I can pay in cash.";
} else {
	print "Time for the credit card.";
}

/*
В функции can_pay_cash() из примера 5.18 сравниваются два ее аргумента. Если значение
аргумента $amount оказывается больше, то данная функция возвращает логическое значение false,
а иначе — логическое значение true. Условный оператор if(), в котором вызывается данная
функция, целенаправленно выполняет собственное назначение, выявляя истинное значение в своем
проверочном выражении. А поскольку это выражение состоит только из вызова функции, то в нем
вызывается функция can_pay_cash() с двумя аргументами 20 и $total. Значение, возвращаемое
данной функцией, оказывается истинным, определяя вывод соответствующего сообщения на экран.
Значение, возвращаемое функцией, можно вводить в проверочное выражение аналогично переменной. 
Но в любом случае, когда вызывается функция, возвращающая значение, ее вызов, например, 
restaurant_check(15.22,8.25,15), заменяется возвращаемым значением при выполнении программы.


Нередко применяемый способ сокращения кода состоит в том, чтобы сочетать вызов функции с
операцией присваивания в проверочном выражении, опираясь на то обстоятельство, что результатом 
присваивания оказывается присваиваемое значение. Это дает возможность вызвать функцию,
сохранить возвращаемое ею значение и проверить, является ли оно истинным (true), за один раз.
В примере 5.19 наглядно демонстрируется, как это делается.
*/

Пример 5.19. Сочетание вызова функции с операцией присваивания проверочном выражении
function complete_bill($meal, $tax, $tip, $cash_on_hand) {
	$tax_amount = $meal * ($tax / 100);
	$tip_amount = $meal * ($tip / 100);
	$total_amount = $meal + $tax_amount + $tip_amount;
	if ($total_amount > $cash_on_hand) {
	// Счет больше, чем имеется наличных
	return false;
	} else {
	// этот счет можно оплатить наличными
	return $total_amount;
	}
}

if ($total = complete_bill(15.22, 8.25, 15, 20)) {
	print "I'm happy to pay $total.";
} else {
	print "I don't have enough money. Shall I wash some dishes?";
}

/*
В примере 5.19 функция complete_bill() возвращает логическое значение false, если рассчитанная 
общая сумма ресторанного счета с учетом налога на добавленную стоимость и чаевых
больше, чем наличная сумма, указанная в аргументе $cash_on_hand. Если общая сумма ресторанного 
счета будет меньше или равна наличной сумме, указанной в аргументе $cash_on_hand, то возвращается 
общая сумма ресторанного счета. Когда же вычисляется проверочное выражение в условном операторе if() 
за пределами вызываемой функции, то происходит следующее.
1. Вызывается функция complete_bill() с аргументами 15.22, 8.25, 15 и 20.
2. Значение, возвращаемое функцией complete_bill(), присваивается переменной $total.
3. Результат присваивания, который, следует напомнить, равен присваиваемому значению, 
преобразуется в логическое значение true или false и далее используется как окончательный
результат вычисления проверочного выражения.

*/

Представление об области действия переменных

/*
Локальные и глобальные переменные действуют одинаково. Так, переменная $dinner в теле
функции, будь она аргументом функции или нет, никак не связана с переменной $dinner за 
пределами функции, а также с переменной $dinner в теле другой функции. Отсутствие такой связи
между переменными в разных областях действия наглядно демонстрируется в примере 5.20.
*/
Пример 5.20. Область действия переменных
$dinner = 'Curry Cuttlefish';
function vegetarian_dinner() {
	print "Dinner is $dinner, or ";
	$dinner = 'Sauteed Pea Shoots';
	print $dinner;
	}
function kosher_dinner() {
	print "Dinner is $dinner, or ";
	$dinner = 'Kung Pao Chicken';
	print $dinner;
}
print "Vegetarian ";
vegetarian_dinner();
print "Kosher ";
kosher_dinner();
print "Regular dinner is $dinner";

/*
Глобальная переменная может быть доступна из тела функции двумя способами. Самый простой 
способ состоит в том, чтобы искать глобальные переменные в специальном массиве $GLOBALS.
Каждая глобальная переменная доступна в качестве элемента этого массива. В примере 5.21 
демонстрируется, как пользоваться массивом $GLOBALS.
*/

Пример 5.21. Доступ к глобальным переменным из массива $GLOBALS
$dinner = 'Curry Cuttlefish';
function macrobiotic_dinner() {
	$dinner = "Some Vegetables";
	print "Dinner is $dinner";
	// насладиться дарами океана
	print " but I'd rather have ";
	print $GLOBALS['dinner'];
}
macrobiotic_dinner();
print "Regular dinner is: $dinner";



Пример 5.22. Видоизменение глобальной переменной в массиве $GLOBALS
$dinner = 'Curry Cuttlefish';
function hungry_dinner() {
	$GLOBALS['dinner'] .= ' and Deep-Fried Taro';
}
print "Regular dinner is $dinner";
hungry_dinner();
print "Hungry dinner is $dinner";

/*
В качестве второго способа доступа к глобальной переменной из функции можно воспользоваться
ключевым словом global. Оно сообщает интерпретатору РНР, что при последующем употреблении
именованной переменной в теле функции следует ссылаться по указанному имени на глобальную, а
не на локальную переменную. Это, по существу, означает введение переменной в локальную область
действия. Применение ключевого слова global показано в примере 5.23
*/

Пример 5.23. Доступ к глобальным переменным с помощью ключевого слова global
$dinner = 'Curry Cuttlefish';
function vegetarian_dinner() {
	global $dinner;
	print "Dinner was $dinner, but now it's ";
	$dinner = 'Sauteed Pea Shoots';
	print $dinner;
}

print "Regular Dinner is $dinner";
vegetarian_dinner();
print "Regular dinner is $dinner";

/*
Ключевое слово global можно применить сразу к нескольким именам переменных, разделив их
запятой, как показано в следующем примере кода:
*/
global $dinner, $lunch, $breakfast;

/*
Как правило, для доступа к глобальным переменным из функций лучше пользоваться
массивом $GLOBALS, а не ключевым словом global. Ссылка на массив $GLOBALS
всякий раз напоминает, что приходится иметь дело с глобальной переменной. Ведь
применяя ключевое слово global, можно очень легко забыть, что оперировать
приходится глобальной переменной, если, конечно, речь не идет о написании
короткой функции. Это может в конечном итоге вызвать недоумение по поводу
неверного поведения кода. И хотя для пользования массивом $GLOBALS придется
ввести чуть больше кода, наградой за эти труды станет удобочитаемость написанного
кода.



Вы, возможно, обратили внимание на некоторую странность приведенных выше примеров, 
демонстрирующих применение массива $GLOBALS. В этих примерах массив $GLOBALS применяется в
теле функции, но не вводится в локальную область действия, как это делается с помощью ключевого
слова global. Массив $GLOBALS всегда остается в глобальной области действия, применяется ли
он в теле функции или за ее пределами. Дело в том, что массив $GLOBALS является особого рода
предопределенной переменной, называемой автоглабальной. Такими переменными можно пользоваться 
в любом месте программы на РНР, не вводя их в область действия. Они подобны сотруднику,
которого знают все в компании (от штаб-квартиры до филиалов), называя его по имени.
Автоглобальные переменные всегда являются массивами, автоматически заполняемыми данными.
Они, в частности, содержат данные из переданной на обработку формы, значения из cookie-файла
и сведения о текущем сеансе.

*/


Соблюдение правил относительно аргументов и возвращаемых значений
/*
Объявления типов означают способ наложения ограничений на значения аргументов. Они ука-
зывают интерпретатору РНР допустимое значение аргумента, чтобы он мог выдать предупреждение,
если предоставлено неверное значение.


array Должен быть массивом, версия РНР 5.1.0
bool Должен быть логическим значением true или false, версия РНР 7.0.0
callable Должен быть чем-то, представляющим функцию или
метод, которые можно вызвать, версия РНР 5.4.0
float Должен быть числом с плавающей точкой, версия РНР 7.0.0
int Должен быть целым числом, версия РНР 7.0.0
string Должен быть символьной строкой, версия РНР 7.0.0
Имя класса Должен быть экземпляром класса (подробнее о классах и
их экземплярах см. в главе 6), версия РНР 5.0.0


При определении функции объявление типа указывается перед именем аргумента. В примере
5.24 демонстрируется функция из примера 5.9 с указанным на своем месте подходящим объявлением 
типа int.
*/

Пример 5.24. Объявление типа аргумента
function countdown(int $top) {
	while ($top > 0) {
		print "$top..";
		$top--;
	}
	print "boom!";
}
$counter = 5;
countdown($counter);
print "Now, counter is $counter";


/*
В версии РНР 7 поддерживаются также объявления типов для значений, возвращаемых функцией. 
Чтобы проверить тип значения, возвращаемого функцией, сначала следует указать знак : после
скобки ), закрывающей список аргументов, а затем объявление возвращаемого типа. Так, в примере
5.25 демонстрируется функция restaurant_check() из примера 5.11, дополненная объявлением
возвращаемого типа. Если функция из примера 5.25 возвратит все, что угодно, только не значение
типа float, интерпретатор РНР сгенерирует исключение TypeError.
*/

Пример 5.25. Объявление возвращаемого типа
function restaurant_check($meal, $tax, $tip): float {
	$tax_amount = $meal * ($tax / 100);
	$tip_amount = $meal * ($tip / 100);
	$total_amount = $meal + $tax_amount + $tip_amount;
return $total_amount;
}

/*
По умолчанию объявления скалярных типов в версии РНР 7 совсем не обязательно
соблюдаются совершенно строго. Даже при объявлении типов в версии РНР 7
предпринимается попытка преобразовать тип аргумента или возвращаемого значения,
которое фактически не соответствует объявлению типа, но могло бы ему
соответствовать. Числовые значения негласно преобразуются в символьные строки, а
символьные строки, содержащие числа, – в значения соответствующего числового
типа.
Этот нескладный режим по умолчанию можно отключить в конкретном файле, введя
в самом его начале строку кода declare(strict_types=1);. В таком случае
аргументы и значения, возвращаемые любой функцией, вызываемой в данном файле,
должны строго соответствовать объявлениям типов. Хотя в качестве аргумента с
объявленным типом float можно передать и целочисленное значение.
Строгую типизацию нельзя соблюсти глобально. Ее придется объявить в каждом
файле, где требуется ее применить.
*/


Выполнение кода из другого файла
/*
В приведенных до сих пор примерах демонстрировался код РНР из отдельных автономных фай-
лов. Любые переменные или функции, использовавшиеся в коде из этих примеров, были определены
в том же самом файле. Но по мере разрастания программ их проще организовать, распределив
исходный код по разным файлам. Для этой цели служит директива require, предписывающая
интерпретатору РНР загрузить код, находящийся в другом файле. Благодаря этому упрощается
повторное использование кода во многих местах программы.
Рассмотрим в качестве примера ряд функций, определенных ранее в этой главе. Их можно
было бы объединить в одном файле и сохранить под именем restaurant-functions.php, как
показано в примере 5.26.


Если сохранить код из примера 5.26 в файле restaurant-functions.php, то к нему можно
обратиться из другого файла с помощью директивы в строке кода require 'restaurantfunctions.php';
(пример 5.27).
*/

Пример 5.27. Обращение к отдельному файлу в исходном коде

require 'restaurant-functions.php';
/* Счет на 25 долларов США плюс налог на добавленную
стоимость (8,875%) и чаевые (20%) */
$total_bill = restaurant_check(25, 8.875, 20);
/* Имеется 30 долларов США наличными */
$cash = 30;
print "I need to pay with " . payment_method($cash, $total_bill);

/*
Директива в строке кода require 'restaurantfunctions.php'; из примера 5.27 предписывает 
интерпретатору РНР прервать чтение команд из текущего файла и перейти к чтению команд
из указанного файла restaurantfunctions.php, а затем вернуться к текущему файлу и продолжить 
его обработку. В файле restaurantfunctions.php из примера 5.27 определен лишь
ряд функций, но файл, загружаемый с помощью директивы require, может содержать любой код,
допустимый в РНР. Так, если загружаемый подобным образом файл содержит операторы print,
интерпретатор РНР выведет на экран все, что указано в этих операторах.
Если не удастся найти загружаемый файл, указанный в директиве require, или же если такой
файл найден, но не содержит допустимый в РНР код, интерпретатор РНР прервет выполнение
программы. Код из другого файла можно также загрузить с помощью директивы include, но если
возникнет затруднение при загрузке файла, то выполнение программы не будет прервано.


!!!
Каким образом интерпретатор РНР обнаруживает файлы
Если в директиве require или include указан абсолютный путь к файлу (в Мас OS X и Linux
он начинается со знака /, а в Windows – с литеры диска или знака \), то интерпретатор РНР будет
искать файл только в том месте, которое указано в пути.
А если в этих директивах указан относительный путь, начинающийся со знаков ./ для
обозначения текущего каталога или со знаков ../ для обозначения родительского каталога для
текущего каталога, то интерпретатор РНР будет искать файл только там, где указано в пути.
Но что касается других предоставляемых имен файлов и путей, то интерпретатор РНР обращается
к директиве конфигурации include_path. Если файл не удастся найти ни в одном из указанных в
ней каталогов, интерпретатор РНР проверит каталог, содержащий файл, в котором требуется или
включается искомый файл.
*/

Оперирование объектами, объединяя данные и логику

/*
Рассмотренных до сих пор основ организации данных и логики их обработки должно быть доста-
точно, чтобы сделать немало полезного в РНР. А дополнительный принцип объектно-ориентирован-
ного программирования (ООП), объединяющий данные и логику, которая ими оперирует, помогает
лучше организовать исходный код. В частности, объекты отлично подходят для создания повторно
используемых фрагментов кода, и поэтому, умея обращаться с ними, можно эффективнее пользо-
ваться многими существующими дополнениями и библиотеками РНР.
В области программирования объект означает структуру, объединяющую данные о каком-нибудь
предмете (например, ингредиенты блюда) с действиями над этим предметом (например, выяснением
наличия определенных ингредиентов в блюде). Применение объектов в программе обеспечивает
организационную структуру для группирования связанных вместе переменных и функций.
Ниже вкратце поясняются основные термины, которые полезно знать для оперирования объекта-
ми.
Класс — это шаблон или образец, описывающий переменные и функции для конкретного вида
объекта. Например, класс Entree может состоять из переменных, содержащих наименование блюда
и его ингредиенты. А функции в классе Entree определяют порядок приготовления и подачи блюда
к столу, а также наличие в нем отдельных ингредиентов.
Метод — это функция, определенная в классе.
Свойство — это переменная, определенная в классе.
Экземпляр — это отдельный пример применения класса. Если на обед подаются три блюда,
то в описывающей их программе следует создать три экземпляра класса Entree. И хотя каждый
из этих экземпляров основывается на одном и том же классе, они имеют внутренние отличия в
значениях их свойств. Методы в каждом экземпляре состоят из одинаковых инструкций, но про-
изводят разные результаты, поскольку каждый из них полагается на конкретные значения свойств
в их экземплярах. Создание нового экземпляра класса называется получением экземпляра объекта.
Конструктор — это специальный метод, который выполняется автоматически при получении
экземпляра объекта. Как правило, в конструкторах устанавливаются свойства объектов и выполня-
ются прочие служебные операции, подготавливающие объект к применению.
Статический метод — это особая разновидность метода, который можно вызывать, не получая
экземпляр класса. Статические методы не зависят от значений свойств конкретного экземпляра.
*/

В примере 6.1 определяется класс Entree, представляющий блюдо.
Пример 6.1. Определение класса
class Entree {
	public $name;
	public $ingredients = array();
	public function hasIngredient($ingredient) {
		return in_array($ingredient, $this->ingredients);
		//in_array — Проверяет, присутствует ли в массиве значение
	}
}

/*
В примере 6.1 определение класса начинается со специального ключевого слова class, после
которого следует имя, присваиваемое классу. Все, что заключено в фигурные скобки после имени
класса, относится к его определению, в том числе свойства и методы класса. У данного класса
имеются два свойства, $name и $ingredients, а также один метод hasIngredient(). Ключевое
слово public сообщает интерпретатору РНР, из каких частей программы разрешается доступ к
конкретному свойству или методу, в объявлении которого указано это ключевое слово. Подробнее
об этом речь пойдет далее, в разделе “Доступность свойств и методов”.
Метод hasIngredient() очень похож на определение обычной функции, но его тело содержит
нечто новое. Это специальная переменная $this, ссылающаяся на тот экземпляр класса, из кото-
рого вызывается метод. 
В примере 6.2 наглядно показано, как это происходит на практике с двумя
разными экземплярами.
*/

Пример 6.2. Создание и применение объектов
// создать экземпляр и присвоить его переменной $soup
$soup = new Entree;
// установить свойства экземпляра в переменной $soup
$soup->name = 'Chicken Soup';
$soup->ingredients = array('chicken', 'water');
// создать отдельный экземпляр и присвоить его
// переменной $sandwich
$sandwich = new Entree;
// установить свойства экземпляра в переменной $sandwich
$sandwich->name = 'Chicken Sandwich';
$sandwich->ingredients = array('chicken', 'bread');

foreach (['chicken','lemon','bread','water'] as $ing) {
	if ($soup->hasIngredient($ing)) {
		print "Soup contains $ing";
	}
	if ($sandwich->hasIngredient($ing)) {
		print "Sandwich contains $ing";
	}
}

/*
Операция new возвращает новый объект типа Entree, поэтому переменные $soup и $sandwich
в коде из примера 6.2 ссылаются на разные экземпляры класса Entree. Операция “стрелка” (->)
служит для доступа к свойствам (т.е. к переменным) и методам (т.е. к функциям) в объекте. Так,
для доступа к свойству достаточно указать операцию “стрелка” после имени объекта, а после этой
операции — имя свойства. Для вызова метода следует указать операцию “стрелка” аналогичным
образом, а после нее — имя метода и круглые скобки, обозначающие вызов функции вместе с
аргументами, если таковые имеются.
Следует, однако, иметь в виду, что операция “стрелка”, предназначенная для доступа к свойствам
и методам, отличается своим обозначением от операции, разделяющей ключи и значения в языковой
конструкции array() или foreach(). Для обозначения доступа к элементам массива служат
знаки =>, тогда как для обозначения доступа к элементам объекта — знаки ->.
Значение присваивается свойству таким же образом, как и любой другой переменной, но для
обозначения имени свойства используется синтаксис операции “стрелка”. В частности, выражение
$soup->name означает свойство name из объекта, экземпляр которого хранится в переменной
$soup, а выражение $sandwich->ingredients — свойство ingredients из объекта, экземпляр
которого хранится в переменной $sandwich.
В цикле, организуемом с помощью языковой конструкции foreach(), вызывается метод has
Ingredient() из каждого объекта. Этому методу передается наименование ингредиента, а из
него возвращается признак наличия или отсутствия данного ингредиента в списке, хранящемся в
объекте. Специальная переменная $this действует в этом методе следующим образом. При вызове
$soup->hasIngredient() переменная $this ссылается в теле метода hasIngredient() на эк-
земпляр объекта, хранящийся в переменной $soup. А при вызове $sandwich->hasIngredient()
переменная $this ссылается на экземпляр объекта, хранящийся в переменной $sandwich. Пере-
менная $this не всегда ссылается на один и тот же экземпляр объекта. Напротив, она ссылается
на тот экземпляр, из которого вызывается метод.
*/


/*
Классы могут также содержать статические методы, в которых нельзя пользоваться специальной
переменной $this, поскольку они выполняются не в контексте конкретного экземпляра объекта,
а в самом классе. Статические методы удобны для реализации поведения, соответствующего на-
значению класса, но ни одному из объектов. В примере 6.3 демонстрируется ввод в класс Entree
статического метода, возвращающего возможные размеры блюд.
*/

Пример 6.3. Определение статического метода

class Entree {
	public $name;
	public $ingredients = array();

	public function hasIngredient($ingredient) {
		return in_array($ingredient, $this->ingredients);
	}
	public static function getSizes() {
		return array('small','medium','large');
	}
}

/*
Объявление статического метода в примере 6.3 очень похоже на объявления других методов, а
отличается оно добавлением ключевого слова static перед ключевым словом function. Чтобы
вызвать статический метод, следует вставить знаки :: между именами класса и метода вместо зна-
ков ->, как показано в примере 6.4.
*/

Пример 6.4. Вызов статического метода
$sizes = Entree::getSizes();

/*
Конструкторы
У класса может быть специальный метод, называемый конструктором и выполняемый при
создании объекта. Конструкторы обычно выполняют установочные и служебные операции для под-
готовки объекта к применению. В качестве примера можно внести изменения в класс Entree,
назначив для него конструктор. Такой конструктор принимает следующие аргументы: наименова-
ние блюда и список его ингредиентов. Передавая эти значения конструктору, можно избежать
установки свойств после создания объекта. Метод-конструктор класса в РНР всегда называет-
ся __construct(). В примере 6.5 демонстрируется измененный класс вместе с его методом-
конструктором.
*/

Пример 6.5. Инициализация объекта в конструкторе
class Entree {
	public $name;
	public $ingredients = array();

	public function __construct($name, $ingredients) {
		$this->name = $name;
		$this->ingredients = $ingredients;
	}

	public function hasIngredient($ingredient) {
		return in_array($ingredient, $this->ingredients);
	}
}

/*
Как показано в примере 6.5, метод-конструктор __construct() принимает два аргумента и
присваивает их значения свойствам класса. Ради удобства аргументам этого метода-конструктора
присвоены такие же имена, как и у свойств создаваемого объекта, хотя интерпретатор РНР этого
и не требует. А в теле данного конструктора обращение к конкретному экземпляру создаваемого
объекта осуществляется по ссылке $this.
Вызывая операцию new, значения аргументов следует указывать после нее в круглых скобках, а
для передачи аргументов конструктору — рассматривать имя класса как имя функции. В примере
6.6 демонстрируется применение конструктора класса Entree для создания экземпляров объектов
$soup и $sandwich, аналогичных упоминавшимся выше.
*/

Пример 6.6. Вызов конструктора
// Суп, его название и ингредиенты
$soup = new Entree('Chicken Soup', array('chicken', 'water'));
// Сэндвич, его название и ингредиенты
$sandwich = new Entree('Chicken Sandwich', array('chicken', 'bread'));

/*
Вызов конструктора в операции new — это лишь часть того, что интерпретатор РНР делает
для создания нового объекта, но сам конструктор не создает объект. Это означает, что метод-
конструктор не возвращает значение и не может использовать возвращаемое значение для уведом-
ления о неверном ходе выполнения кода, поскольку это задача исключений, рассматриваемых в
следующем разделе.
*/


/*
В примере 6.7 демонстрируется конструктор класса Entree, в который внесены изменения для
генерирования исключения в том случае, если аргумент $ingredients не содержит массив. (Ге-
нерирование исключения означает применение исключения для уведомления интерпретатора РНР о
неверном ходе выполнения кода.)
*/

Пример 6.7. Генерирование исключения
class Entree {
	public $name;
	public $ingredients = array();

	public function __construct($name, $ingredients) {
		if (! is_array($ingredients)) {
			throw new Exception('$ingredients must be an array');
		}
		$this->name = $name;
		$this->ingredients = $ingredients;
	}

	public function hasIngredient($ingredient) {
		return in_array($ingredient, $this->ingredients);
	}
}

/*
Обратной стороной медали генерирования исключений является их перехват, прежде чем они достигнут ин-
терпретатора РНР и будут обработаны в нем как неисправимые ошибки.
Чтобы самостоятельно обработать исключение, необходимо выполнить следующие действия.
1. Разместить в блоке оператора try код, в котором может быть сгенерировано исключение.
2. Разместить блок оператора catch после кода, в котором может быть сгенерировано исключе-
ние, чтобы обработать исключение и устранить возникшую ошибку.
В примере 6.9 демонстрируется порядок ввода в исходный код блоков операторов try и catch
для обработки исключения.
*/

Пример 6.9. Обработка исключения
try {
	$drink = new Entree('Glass of Milk', 'milk');
	if ($drink->hasIngredient('milk')) {
			print "Yummy!";
		}
} catch (Exception $e) {
	print "Couldn't create the drink: " . $e->getMessage();
}

/*
Расширение объектов
Объекты удобны для организации кода, в частности, тем, что они подлежат подклассификации,
которая позволяет повторно использовать класс, дополняя его специальными функциональными воз-
можностями. Подкласс, иногда еще называемый порожденным, наследует все методы и свойства от
существующего класса, называемого родительским, а далее он изменяет их или вводит собственные
свойства и методы.
Рассмотрим в качестве примера блюдо, которое не является простым, а состоит из ряда дру-
гих блюд, например, тарелки супа и сендвича. Это положение можно было бы смоделировать в
существующем классе Entree, отнеся суп и сендвич в числу ингредиентов или перечислив все
ингредиенты супа и сендвича в данном составном блюде. Но ни одно из этих решений не явля-
ется идеальным. Ведь суп и сендвич, по существу, не являются ингредиентами, а для повторного
перечисления ингредиентов блюда придется обновить код во многих местах при изменении любого
ингредиента.
Данную задачу можно решить более изящно, создав подкласс, производный от класса Entree.
Он должен получать экземпляры объектов класса Entree в качестве ингредиентов, видоизменив
метод hasIngredient() для проверки этих экземпляров на наличие в них ингредиентов. Опреде-
ление этого производного класса ComboMeal приведено в примере 6.10.
*/

Пример 6.10. Расширение класса Entree
class ComboMeal extends Entree {

	public function hasIngredient($ingredient) {
		foreach ($this->ingredients as $entree) {
			if ($entree->hasIngredient($ingredient)) {
				return true;
			}
		}
		return false;
	}
}

/*
В коде из примера 6.10 после имени класса ComboMeal следует предложение extends Entree,
которое сообщает интерпретатору РНР, что класс ComboMeal должен наследовать от класса Entree
все его методы и свойства. Для интерпретатора РНР это означает переопределение класса Entree
в определении класса ComboMeal. Хотя это делается автоматически, избавляя программиста от
рутинной работы, и ему остается лишь внести изменения и дополнения в фигурных скобках опре-
деления класса ComboMeal. В данном примере единственным изменением является новый метод
hasIngredient(). Вместо того чтобы исследовать свойство $this->ingredients как массив,
в данном классе оно рассматривается как массив объектов типа Entree, и для каждого из этих
объектов вызывается метод hasIngredient(). Если в результате любого из таких вызовов воз-
вращается логическое значение true, это означает, что одно из блюд в составном блюде содержит
указанный ингредиент, а следовательно, метод hasIngredient() из класса ComboMeal возвраща-
ет логическое значение true. Если же после перебора всех блюд логическое значение true вообще
не возвращается, то данный метод возвратит логическое значение false, а это означает, что ни
одно из блюд не содержит ингредиенты. Применение подкласса ComboMeal наглядно демонстриру-
ется в примере 6.11.
*/

Пример 6.11. Применение подкласса
// Суп, его название и ингредиенты
$soup = new Entree('Chicken Soup', array('chicken', 'water'));
// Сендвич, его название и ингредиенты
$sandwich = new Entree('Chicken Sandwich', array('chicken', 'bread'));
// Составное блюдо
$combo = new ComboMeal('Soup + Sandwich', array($soup, $sandwich));
foreach (['chicken','water','pickles'] as $ing) {
if ($combo->hasIngredient($ing)) {
print "Something in the combo contains $ing.\n";
}
}

/*
Такой подход вполне пригоден, но он не гарантирует, что аргументы, передаваемые конструктору
класса ComboMeal, действительно являются объектами класса Entree. Ведь если они таковыми не
являются, то вызов для них метода hasIngredient() может привести к ошибке. Чтобы устранить
этот недостаток, необходимо ввести в класс ComboMeal специальный конструктор, проверяющий
данное условие и вызывающий обычный конструктор класса Entree с целью правильно установить
свойства его объекта. Вариант класса ComboMeal с таким конструктором приведен в примере 6.12.
*/

Пример 6.12. Ввод конструктора в подкласс

class ComboMeal extends Entree {

	public function __construct($name, $entrees) {
		parent::__construct($name, $entrees);
		foreach ($entrees as $entree) {
			if (! $entree instanceof Entree) {
			throw new Exception(
			'Elements of $entrees must be Entree objects');
			}
		}
	}

	public function hasIngredient($ingredient) {
		foreach ($this->ingredients as $entree) {
			if ($entree->hasIngredient($ingredient)) {
				return true;
			}
		}
		return false;
	}
}

/*

Оператор разрешения области видимости (также называемый "Paamayim Nekudotayim") или просто 
"двойное двоеточие" - это лексема, позволяющая обращаться к статическим свойствам, константам 
и переопределенным свойствам или методам класса. При обращении к этим элементам извне класса, 
необходимо использовать имя этого класса. Начиная с версии PHP 5.3.0, стало возможным обратиться 
к классу с помощью переменной. Значение переменной не должно быть ключевым словом (например, 
self, parent или static).


class MyClass {
    const CONST_VALUE = 'Значение константы';
}

$classname = 'MyClass';
echo $classname::CONST_VALUE; // Начиная с PHP 5.3.0

echo MyClass::CONST_VALUE;


class OtherClass extends MyClass
{
    public static $my_static = 'статическая переменная';

    public static function doubleColon() {
        echo parent::CONST_VALUE . "\n";
        echo self::$my_static . "\n";
    }
}

$classname = 'OtherClass';
$classname::doubleColon(); // Начиная с версии PHP 5.3.0
OtherClass::doubleColon();
*/

/*
Замечание: Конструкторы, определенные в классах-родителях не вызываются автоматически, 
если дочерний класс определяет собственный конструктор. Чтобы вызвать конструктор, объявленный 
в родительском классе, требуется вызвать parent::__construct() внутри конструктора дочернего класса. 
Если в дочернем классе не определен конструктор, то он может быть унаследован от родительского класса 
как обычный метод (если он не был определен как приватный).
*/

/*
В конструкторе из примера 6.12 применяется специальный синтаксис parent::__construct()
для ссылки на конструктор из класса Entree. Аналогично ссылке $this, этот синтаксис име-
ет особое назначение в методах объектов. В частности, ключевое слово parent означает ссылку
на родительский класс. А поскольку класс ComboMeal расширяет класс Entree, то при вызове
parent::__construct() в порожденном классе ComboMeal происходит обращение к конструк-
тору __construct() родительского класса Entree.
Не следует забывать, что конструктор родительского класса нужно вызывать в конструкторах
подкласса явным образом. Так, если опустить вызов parent::__construct(), родительский
конструктор вообще не будет вызван, и его важное, вероятно, поведение так и не будет воспро-
изведено в интерпретаторе РНР. В данном случае конструктор класса Entree вызывается, чтобы
проверить, содержит ли аргумент $ingredients массив, а затем установить свойства $name и
$ingredients.
После вызова parent::__construct() в конструкторе класса ComboMeal проверяется, яв-
ляется ли каждый предоставляемый ингредиент составного блюда объектом класса Entree. И
для этой цели применяется операция instanceof.

Оператор instanceof используется для определения того, является ли текущий объект экземпляром указанного 
класса.

Условное выражение $entree instanceof
Entree оказывается истинным, если переменная $entree ссылается на экземпляр объекта класса
Entree.1 Если же любой из предоставляемых ингредиентов, которые для класса ComboMeal на
самом деле являются блюдами, не является объектом класса Entree, то в рассматриваемом здесь
коде генерируется исключение.

1 Результат выполнения операции instanceof также оказывается истинным, если объект в левой части данной
операции относится к подклассу, производному от класса, имя которого указывается в правой ее части. 
Рассматриваемый здесь код пригоден, например, для одних составных блюд, состоящих из других составных блюд.
*/

/*
Доступность свойств и методов
Конструктор класса ComboMeal из примера 6.12 делает немало для того, чтобы класс ComboMeal
получал экземпляры класса Entree только в качестве ингредиентов составного блюда. Но что про-
исходит дальше? В последующем коде значение свойства $ingredients может быть изменено на
все, что угодно: массив любых объектов, кроме класса Entree, число или даже логическое значение
false.
Чтобы воспрепятствовать такому нежелательному поведению, следует изменить доступность
свойств. В частности, их можно объявить закрытыми (private) или защищенными (protected),
а не открытыми (public). Два первых модификатора доступа не оказывают влияния на то, что код
класса может делать в нем самом, например, читать и записывать значения его свойств. В частности,
модификатор доступа private препятствует любому коду за пределами класса обращаться к его
свойству. А модификатор доступа protected означает, что к свойству класса можно обращаться
за его пределами только из кода его подклассов.
В примере 6.13 демонстрируется видоизмененный вариант класса Entree, в котором свойство
$name объявлено как private, а свойство $ingredients — как protected.
*/

Пример 6.13. Изменение доступности свойств

class Entree {

	private $name;
	protected $ingredients = array();
	/* Свойство $name объявлено закрытым, и поэтому ниже
	предоставляется метод для чтения его значения */
	
	public function getName() {
		return $this->name;
	}

	public function __construct($name, $ingredients) {
		if (! is_array($ingredients)) {
			throw new Exception('$ingredients must be an array');
		}
		$this->name = $name;
		$this->ingredients = $ingredients;
	}
	public function hasIngredient($ingredient) {
		return in_array($ingredient, $this->ingredients);
	}
}

/*
Пространства имен
Начиная с версии 5.4, интерпретатор РНР позволяет организовывать код в пространствах имен.
В пространствах имен можно группировать связанный вместе код, исключая конфликты имен клас-
сов, одинаково названных разными их авторами2.
Уметь правильно пользоваться пространствами имен очень важно для внедрения в свои про-
граммы пакетов, разработанных другими. В этом разделе дается общее представление о синтаксисе
пространств имен. А в главе 16 подробно описывается система управления пакетами Composer.
Пространства имен можно рассматривать в качестве контейнера, где допускается хранить опре-
деления классов или даже другие пространства имен. Это делается ради удобства, а не ради предо-
ставления новых функциональных возможностей. Когда в исходном коде встречается ключевое слово
namespace и путь к классу, это означает вхождение в пространство имен РНР.
Чтобы определить класс в конкретном пространстве имен, достаточно указать ключевое слово
namespace с наименованием пространства имен в самом начале исходного файла. И тогда опре-
деление класса далее в исходном файле будет отнесено к указанному пространству имен. Так, в
примере 6.14 класс Fruit определяется в пространстве имен Tiny.
*/

Пример 6.14. Определение класса в пространстве имен

namespace Tiny;
class Fruit {
	public static function munch($bite) {
		print "Here is a tiny munch of $bite.";
	}
}

/*
Чтобы воспользоваться классом в пространстве имен, необходимо внедрить это пространство
имен в порядок обращения к классу. Самый простой способ сделать это однозначно — указать
сначала знак \, обозначающий пространство имен верхнего уровня, затем имя пространства имен, в
котором находится класс, далее еще один знак \ и имя класса. Например, чтобы вызвать статический
метод munch() из класса Fruit, определенного в примере 6.14, достаточно написать следующую
строку кода:
*/
\Tiny\Fruit::munch("banana");

/*
Одни пространства имен могут также состоять из других пространств имен. Если бы код из
примера 6.14 начинался со строки namespace Tiny\Eating;, то обратиться к классу Fruit
следовало бы следующим образом: \Tiny\Eating\Fruit.
Если не указать в начале знак \, то обращение к классу осуществляется в текущем простран-
стве имен, т.е. в том пространстве имен, которое оказывается активным в момент обращения. Если
пространство имен не объявлено в самом начале исходного файла РНР, то к верхнему уровню отно-
сится текущее пространство имен, а имена классов ведут себя, как обычные имена классов, встре-
чавшиеся в приведенных ранее примерах кода. Но ключевое слово namespace изменяет текущее
пространство имен. Так, в объявлении namespace Tiny; текущее пространство имен изменяется
на Tiny. Именно поэтому определение class Fruit в коде из примера 6.14 приводит к тому, что
класс Fruit размещается в пространстве имен Tiny.
Но это означает также, что ссылка на любой другой класс в том же самом исходном файле
разрешается относительно пространства имен Tiny. Метод из класса Tiny\Fruit, содержащий
следующую строку кода:
$soup = new Entree('Chicken Soup', array('chicken','water'));
предписывает интерпретатору РНР искать класс Entree в пространстве имен Tiny. Это все равно,
что написать такую строку кода:
$soup = new \Tiny\Entree('Chicken Soup', array('chicken','water'));
Чтобы сделать однозначным обращение к классу в пространстве имен верхнего уровня, необ-
ходимо указать знак \ перед именем этого класса. Безусловно, набирать многократно знаки \ в
исходном коде довольно утомительно. Поэтому интерпретатор РНР предоставляет ради упрощения
ключевое слово use. В примере 6.15 наглядно показано, как пользоваться ключевым словом use.
*/

Пример 6.15. Применение ключевого слова use
use Tiny\Eating\Fruit as Snack;
use Tiny\Fruit;
// Приведенная ниже строка кода равнозначна
// такой строке кода: \Tiny\Eating\Fruit::munch();
Snack::munch("strawberry");
// Приведенная ниже строка кода равнозначна
// такой строке кода: \Tiny\Fruit::munch();
Fruit::munch("orange");

/*
В строке кода use Tiny\Eating\Fruit as Snack; из примера 6.15 интерпретатору РНР
предписывается считать имя Snack в остальной части исходного файла как \Tiny\Eating\Fruit.
Если не указать предложение as, интерпретатор РНР выведет “псевдоним” класса из последнего
элемента, определенного для применения с помощью ключевого слова use. Таким образом, в строке
кода use Tiny\Fruit; интерпретатору РНР предписывается считать имя Fruit в остальной
части исходного файла как \Tiny\Fruit.
Такого рода объявления с помощью ключевого
*/

Упражнения

/*
1. Создайте класс Ingredient. Каждый экземпляр этого класса должен представлять отдельный
ингредиент блюда, а также отслеживать наименование ингредиента и его стоимость.
*/


Упражнение 1
class Ingredient {
	protected $name;
	protected $cost;

	public function __construct($name, $cost) {
		$this->name = $name;
		$this->cost = $cost;
	}

	public function getName() {
		return $this->name;
	}

	public function getCost() {
		return $this->cost;
	}
}

// 2. Введите в свой новый класс Ingredient метод, изменяющий стоимость ингредиента блюда.
Упражнение 2

class Ingredient {
	protected $name;
	protected $cost;

	public function __construct($name, $cost) {
		$this->name = $name;
		$this->cost = $cost;
	}

	public function getName() {
		return $this->name;
	}

	public function getCost() {
		return $this->cost;
	}
	// В следующем методе задается новая величина
	// стоимости ингредиента блюда
	public function setCost($cost) {
		$this->cost = $cost;
	}
}


/*
3. Создайте подкласс, производный от представленного в этой главе класса Entree. Этот под-
класс должен принимать объекты типа Ingredient вместо символьной строки с наимено-
ваниями ингредиентов для их обозначения. Введите в этот подкласс метод, возвращающий
общую стоимость блюда.
*/
Упражнение 3

class PricedEntree extends Entree {
	public function ___construct($name, $ingredients) {
		parent::__construct($name, $ingredients);
		foreach ($this->ingredients as $ingredient) {
			if (! $ingredient instanceof Ingredient) {
				throw new Exception('Elements of $ingredients
				must be Ingredient objects');
			}
		}
	}

	public function getCost() {
		$cost = 0;
		foreach ($this->ingredients as $ingredient) {
			$cost += $ingredient->getCost();
		}
		return $cost;
	}
}

Упражнение 4
//Класс Ingredient размещается в собственном пространстве имен следующим образом:
//namespace Meals;
class Ingredient {
	protected $name;
	protected $cost;

	public function ___construct($name, $cost) {
		$this->name = $name;
		$this->cost = $cost;
	}

	public function getName() {
		return $this->name;
	}

	public function getCost() {
		return $this->cost;
	}
	// В следующем методе задается новая величина
	// стоимости ингредиента блюда
	public function setCost($cost) {
		$this->cost = $cost;
	}
}

//А обращение к данному пространству имен из класса PricedEntree осуществляется таким
//образом:
class PricedEntree extends Entree {
	public function ___construct($name, $ingredients) {
		parent::__construct($name, $ingredients);
		foreach ($this->ingredients as $ingredient) {
			if (! $ingredient instanceof \Meals\Ingredient) {
				throw new Exception('Elements of $ingredients
				must be Ingredient objects');
			}
		}
	}
	public function getCost() {
		$cost = 0;
		foreach ($this->ingredients as $ingredient) {
			$cost += $ingredient->getCost();
		}
		return $cost;
	}
}

ГЛАВА 7
Создание веб-форм для обмена данными с пользователями

Пример 7.1. Отображение приветствия на странице
if ('POST' == $_SERVER['REQUEST_METHOD']) {
print "Hello, ". $_POST['my_name'];
} else {
print<<<_HTML_
<form method="post" action="$_SERVER[PHP_SELF]">
Your name: <input type="text" name="my_name" >
<br>
<input type="submit" value="Say Hello">
</form>
_HTML_;
}

/*
Доступ к параметрам формы
В начале каждого запроса интерпретатор РНР устанавливает ряд автоглобальных массивов, со-
держащих значения любых параметров, переданных в форме или в URL. Параметры URL и форм,
извлекаемых методом GET, размещаются в массиве $_GET, а параметры форм, передаваемых мето-
дом POST, — в массиве $_POST.
Например, по следующему URL:
http://www.example.com/catalog.php?product_id=21&category=fryingpan
в массиве $_GET размещаются перечисленные ниже значения:
• значение 21 в элементе массива $_GET[’product_id’];
• значение fryingpan в элементе массива $_GET[’category’].
Передача формы на обработку в примере 7.2 приводит к тому, что в массиве $_POST размеща-
ются одни и те же значения, при условии, что в текстовом поле формы введено значение 21, а из
списка выбран элемент Frying Pan (Сковородка).
*/


Пример 7.2. Двухэлементная форма
<form method="POST" action="catalog.php">
<input type="text" name="product_id">
<select name="category">
<option value="ovenmitt">Pot Holder</option>
<option value="fryingpan">Frying Pan</option>
<option value="torch">Kitchen Torch</option>
</select>
<input type="submit" name="submit">
</form>

/*
Форма из примера 7.2 внедряется в исходный код программы на РНР из примера 7.3, где на
экран выводятся соответствующие значения из массива $_POST после отображения формы. В атри-
буте action дескриптора <form> разметки формы из примера 7.3 указано значение catalog.php,
поэтому данную программу нужно сохранить в файле catalog.php на веб-сервере. Если же ее
требуется сохранить в файле под другим именем, откорректируйте соответственно значение атрибу-
та action.
*/

Пример 7.3. Вывод на экран параметров из формы, переданной на обработку

<form method="POST" action="catalog.php">
<input type="text" name="product_id">
<select name="category">
<option value="ovenmitt">Pot Holder</option>
<option value="fryingpan">Frying Pan</option>
<option value="torch">Kitchen Torch</option>
</select>
<input type="submit" name="submit">
</form>
Here are the submitted values:
product_id: <?php print $_POST['product_id'] ?? '' ?>
<br/>
category: <?php print $_POST['category'] ?? '' ?>


/*
Во избежание появления предупреждающего сообщения от интерпретатора РНР о том случае,
если переменные не были переданы методом POST, в примере 7.3 применяется нулеобъединяющая
операция ?? ''. Так, в выражении $_POST['product_id'] ?? '' вычисляется значение элемента
$_POST['product_id'], если в нем вообще что-нибудь содержится, а иначе — пустая строка
(' '). Если не принять этой меры предосторожности, появится сообщение вроде "РНР Notice:
Undefined index: product_id" (Предупреждение РНР: неопределенный индекс: product_id),
если страница была извлечена методом GET, но переменные, передаваемые методом POST, не уста-
новлены.

Нулеобъединяющая операция была внедрена в версии РНР 7. Если вы пользуетесь
более ранней версией РНР, применяйте вместо этой операции функцию isset()
следующим образом:
*/

if (isset($_POST['product_id'])) {
print $_POST['product_id'];
}

/*
Если элемент формы может принимать несколько значений, после его имени следует указать
квадратные скобки ([]). Этим интерпретатору РНР предписывается считать несколько значений
элементами массива. Так, в списке, размеченном дескриптором <select> в примере 7.4, имеется
несколько переданных значений, размещаемых в элементе массива $_POST['lunch'].
*/

Пример 7.4. Элементы формы с несколькими значениями

<form method="POST" action="eat.php">
<select name="lunch[]" multiple>
<option value="pork">BBQ Pork Bun</option>
<option value="chicken">Chicken Bun</option>
<option value="lotus">Lotus Seed Bun</option>
<option value="bean">Bean Paste Bun</option>
<option value="nest">Bird-Nest Bun</option>
</select>
<input type="submit" name="submit">
</form>

/*
Если передать на обработку форму из примера 7.4 с выбранными вариантами Chicken Bun (Бу-
лочка с цыпленком) и Bird-Nest Bun (Булочка “Птичье гнездо”), то значение элемента массива
$_POST['lunch'] превратится в двухэлементный массив, содержащий значения chicken и nest.
Доступ к этим значениям осуществляется с помощью обычного синтаксиса многомерных массивов.
В примере 7.5 форма из примера 7.4 внедряется в программу, выводящую на экран каждый вариант,
выбранный из списка. (Здесь применяется то же самое правило к имени файла и атрибуту action.
Сохраните исходный код из примера 7.5 в файле eat.php или откорректируйте значение атрибута
action в дескрипторе <form>, если потребуется изменить имя файла.)
*/

Пример 7.5. Доступ к нескольким значениям элемента формы

<form method="POST" action="eat.php">
<select name="lunch[]" multiple>
<option value="pork">BBQ Pork Bun</option>
<option value="chicken">Chicken Bun</option>
<option value="lotus">Lotus Seed Bun</option>
<option value="bean">Bean Paste Bun</option>
<option value="nest">Bird-Nest Bun</option>
</select>
<input type="submit" name="submit">
</form>
Selected buns:
<br/>


if (isset($_POST['lunch'])) {
	foreach ($_POST['lunch'] as $choice) {
		print "You want a $choice bun. <br/>";
	}
}


/*
Если из списка выбраны варианты Chicken Bun и Bird-Nest Bun, то при выполнении кода
из примера 7.5 на экран (после самой формы) выводится следующий результат:
Selected buns:
You want a chicken bun.
You want a nest bun.
Элемент формы lunch[] можно рассматривать как преобразуемый в приведенный ниже код
РНР при передаче формы на обработку. При этом предполагается, что переданы значения chicken
и nest элемента формы. Как было показано в примере 4.6, такой синтаксис добавляет элемент в
конце массива.
*/
$_POST['lunch'][] = 'chicken';
$_POST['lunch'][] = 'nest';

Обработка форм с помощью функций
/*
Элементарную форму из примера 7.1 можно сделать более гибкой, перенеся код отображения и
обработки в отдельные функции. Этот вариант формы из примера 7.1 демонстрируется в примере 7.6
с применением функций. Чтобы изменить форму или то, что с ней происходит, когда она передается
на обработку, внесите изменения в тело функции process_form() или show_form().
*/

Пример 7.6. Отображение приветствия "Hello" на странице с применением функций
// Логика выполнения верных действий на
// основании метода запроса
if ($_SERVER['REQUEST_METHOD'] == 'POST') {
	process_form();
} else {
	show_form();
}
// сделать что-нибудь, когда форма передана на обработку
function process_form() {
	print "Hello, ". $_POST['my_name'];
}
// отобразить форму
function show_form() {
	print<<<_HTML_
	<form method="POST" action="$_SERVER[PHP_SELF]">
	Your name: <input type="text" name="my_name">
	<br />
	<input type="submit" value="Say Hello">
	</form>
	_HTML_;
}

/*
Разделение обработки и отображения формы на отдельные функции упрощает также внедрение
стадии проверки достоверности данных, которая рассматривается более подробно далее, в разде-
ле “Проверка достоверности данных”. А до тех пор достаточно сказать, что проверка достоверности
данных является очень важной функцией любого веб-приложения, принимающего данные, вводимые
в форме. После передачи формы на обработку введенные в ней данные должны быть непременно
проверены на достоверность, прежде чем приступать к их обработке. В примере 7.7 показано внед-
рение функции проверки достоверности в код из примера 7.6.
*/


// Логика выполнения верных действий на
// основании метода запроса
if ($_SERVER['REQUEST_METHOD'] == 'POST') {
	if (validate_form()) {
		process_form();
	} else {
		show_form();
	}
} else {
	show_form();
}

// сделать что-нибудь, когда форма передана на обработку
function process_form() {
	print "Hello, ". $_POST['my_name'];
}

// отобразить форму
function show_form() {
print<<<_HTML_
<form method="POST" action="$_SERVER[PHP_SELF]">
Your name: <input type="text" name="my_name">
<br/>
<input type="submit" value="Say Hello">
</form>
_HTML_;
}

// проверить данные из формы
function validate_form() {
	// Содержит ли имя, введенное в текстовом поле my_name
	// хотя бы три символа?
	if (strlen($_POST['my_name']) < 3) {
		return false;
	} else {
		return true;
	}
}


Проверка достоверности данных
/*
Как упоминалось ранее, в коде из примера 7.7 не указывается, что неверно введено в форме,
если проверка в функции validate_form() не пройдет. Поэтому в примере 7.8 внесены измене-
ния в функции validate_form() и show_form() для составления и вывода на экран массива
возможных сообщений об ошибках.
*/

Пример 7.8. Отображение сообщений об ошибках вместе с формой

// Логика выполнения верных действий на
// основании метода запроса
if ($_SERVER['REQUEST_METHOD'] == 'POST') {
	// Если функция validate_form() возвратит ошибки,
	// передать их функции show_form()
	if($form_errors = validate_form()) {
		show_form($form_errors);
	} else {
	process_form();
	}
} else {
	show_form();
}

// сделать что-нибудь, когда форма передана на обработку
function process_form() {
	print "Hello, ". $_POST['my_name'];
}

// отобразить форму
function show_form($errors = ) {
// Если переданы ошибки, вывести их на экран
if ($errors) {
	print 'Please correct these errors: <ul><li>';
	print implode ('</li><li>', $errors);
	print ' </li></ul>';
}
print <<<_HTML_
<form method="POST" action="$_SERVER[PHP_SELF]">
Your name: <input type="text" name="my_name">
<br/>
<input type="submit" value="Say Hello">
</form>
_HTML_;
}

// проверить данные из формы
function validate_form() {
// начать с пустого массива сообщений об ошибках
$errors = array();
// добавить сообщение об ошибке, если введено слишком
// короткое имя
if(strlen($_POST['my_name']) < 3) {
$errors[ ] = 'Your name must be at least 3 letters long.';
}
// возвратить (возможно, пустой) массив сообщений об ошибках
return $errors;
}


/*
В коде из примера 7.8 выгодно используется тот факт, что пустой массив вычисляется как
ложный (false). В следующей строке кода определяется, следует ли снова вызывать функцию
show_form() и передавать ей массив сообщений об ошибках или же нужно вызвать функцию
process_form():
if ($form_errors = validate_form())

Массив, возвращаемый функцией validate_form(), присваивается переменной $form_errors.
Истинное значение проверочного выражения в условном операторе if() является результатом этого
присваивания, поскольку присваивается конкретное значение, как пояснялось выше, в разделе “Об-
щее представление об истинности или ложности” главы 3. Таким образом, проверочное выражение
в условном операторе if() оказывается истинным (true), если переменная $form_errors со-
держит какие-нибудь элементы массива. А если переменная $form_errors пуста, то проверочное
выражение оказывается ложным (false). Функция validate_form() возвратит пустой массив,
если не обнаружатся никакие ошибки.
Достоверность всех элементов формы целесообразно проверить за один проход, чтобы не отобра-
жать повторно форму всякий раз, когда недостоверные данные будут обнаружены в одном элементе
формы. Пользователь должен обнаружить все свои ошибки после передачи формы на обработку,
чтобы не повторять ее передачу каждый раз, когда появится новое сообщение об ошибке. С этой
целью в функции validate_form() из примера 7.8 по каждой ошибке, обнаруженной в форме,
вводится отдельный элемент в массив $errors. А в функции show_form() на экран выводятся
соответствующие сообщения об ошибках.
Все методы проверки достоверности в данном примере сосредоточены в функции validate_form().
Если элемент формы не проходит проверку достоверности, то соответствующее сообщение вводится
в массив $errors.
*/



Обязательные элементы формы
/*
Чтобы выяснить, было ли что-нибудь введено в обязательном элементе формы, следует проверить
длину значения в этом элементе с помощью функции strlen(), как показано в примере 7.9.
*/

Пример 7.9. Проверка достоверности данных в обязательном элементе
if (strlen($_POST['email']) == 0) {
	$errors[] = "You must enter an email address.";
}

/*
При проверке обязательного элемента формы очень важно воспользоваться функцией strlen()
вместо условного оператора if(). Ведь при проверке вроде if(! $_POST[’quantity’]) значе-
ние, вычисляемое как ложное (false), интерпретируется как ошибка. А если применить функцию
strlen(), то пользователи смогут ввести в обязательном элементе даже такое значение, как 0.
*/

Числовые или строковые элементы формы

/*
Чтобы убедиться, что переданное на обработку значение является целым числом или числом с
плавающей точкой, следует вызвать функцию filter_input() с подходящим фильтром. С помо-
щью функции filter_input() интерпретатору РНР можно указать, какими именно входными
данными следует оперировать, а также наименование переданного значения во входных данных и
правило, которому это значение должно соответствовать. В частности, фильтры FILTER_VALIDATE
_INT и FILTER_VALIDATE_FLOAT осуществляют проверку на целые числа и числа с плавающей
точкой соответственно.

https://www.php.net/manual/ru/function.filter-input.php
filter_input — Принимает переменную извне PHP и, при необходимости, фильтрует ее

filter_input ( int $type , string $variable_name [, int $filter = FILTER_DEFAULT [, mixed $options ]] ) : mixed
Список параметров ¶
type
Одна из констант INPUT_GET, INPUT_POST, INPUT_COOKIE, INPUT_SERVER или INPUT_ENV.

variable_name
Имя получаемой переменной.

filter
Идентификатор (ID) применяемого фильтра. На странице Типы фильтров приведен список доступных фильтров.
https://www.php.net/manual/ru/filter.filters.validate.php

Если не указан, то используется FILTER_DEFAULT, который равнозначен FILTER_UNSAFE_RAW. Это значит, 
что по умолчанию не применяется никакого фильтра.

options
Ассоциативный массив параметров или логическое ИЛИ флагов. Если фильтр принимает параметры, флаги 
могут быть указаны в элементе массива "flags".

Возвращаемые значения
Значение запрашиваемой переменной в случае успеха, FALSE, если фильтрация завершилась неудачей, или 
NULL, если переменная variable_name не определена. Если установлен флаг FILTER_NULL_ON_FAILURE, функция 
возвращает FALSE, если переменная не определена и NULL, если фильтрация завершилась неудачей.



В примере 7.10 демонстрируется применение фильтра целых чисел.
Пример 7.10. Фильтрация целочисленных входных данных
*/

$ok = filter_input(INPUT_POST, 'age', FILTER_VALIDATE_INT);
if (is_null($ok) || ($ok === false)) {
	$errors[] = 'Please enter a valid age.';
}

/*
В строке кода filter_input(INPUT_POST, ’age’, FILTER_VALIDATE_INT) из примера
7.10 интерпретатору РНР предписывается проверить данные из переданной на обработку формы
(INPUT_POST), особенно из поля формы age, и проверить их относительно фильтра целых чисел
(FILTER_VALIDATE_INT). Функции filter_input() указывается, где искать проверяемые дан-
ные (аргумент INPUT_POST) и какое поле следует проверять (аргумент age), а не элемент массива
вроде $_POST['age'], чтобы она могла надлежащим образом обработать отсутствующие данные,
избежав недоразумений на тот случай, если программа РНР изменит значения в массиве $_POST.
Если функция filter_input() обнаружит, что значение в указанном элементе введено верно,
она возвратит это значение. Если значение в указанном элементе не введено, она возвратит пустое
значение null. А если значение в указанном элементе введено, но недостоверно в соответствии
с заданным фильтром, то данная функция возвратит логическое значение false. В проверочном
выражении условного оператора if() из примера 7.10 переменная $ok сравнивается с логическим
значением false посредством операции ===, называемой операцией тождественности. При срав-
нении значений в этой операции вычисляется логическое значение true, если оба значения одинаковы
и однотипны. Как было показано в примере 3.11, при сравнении двух разнотипных значений (на-
пример, строкового и целочисленного или логического и целочисленного) интерпретатор РНР может
изменить типы значений, чтобы сравнить их. Так, если в переданной на обработку форме было вве-
дено нулевое значение, которое является достоверным целым числом, то значение переменной $ok
будет равно нулю. И тогда обычное сравнение значения переменной $ok с логическим значением
false даст истинный результат, поскольку нулевое значение вычисляется как ложное (false).
А операция тождественности даст ложный результат, поскольку типы сравниваемых значений не
совпадают.
Это означает, что в массив $errors вводится сообщение об ошибке, если значение в поле
формы age отсутствует (проверка is_null($ok)) или не является целочисленным (проверка $ок
=== false). Аналогичным образом осуществляется фильтрация чисел с плавающей точкой, как
показано в примере 7.11.
*/

Пример 7.11. Фильтрация числовых входных данных с плавающей точкой
$ok = filter_input(INPUT_POST, 'price', FILTER_VALIDATE_FLOAT);
if (is_null($ok) || ($ok === false)) {
$errors[] = 'Please enter a valid price.';
}

/*
При проверке достоверности данных (особенно строковых) в элементах заполняемой формы
нередко полезно удалить начальные и конечные пробелы с помощью функции trim(). Эту функ-
цию можно применять вместе с функцией strlen() для проверки обязательных элементов, чтобы
исключить ввод одних только пробелов (пример 7.12).
*/

Пример 7.12. Совместное применение функций trim() и strlen()
if (strlen(trim($_POST['name'])) == 0) {
$errors[] = "Your name is required.";
}

/*
Bсe URL и данные из передаваемой на обработку формы поступают в интерпретатор РНР в виде
символьных строк. Если функции filter_input() задан числовой фильтр (и передано достовер-
ное числовое значение), она возвратит значение, преобразуемое в целое число или число с плава-
ющей точкой. Аналогично удалению лишних пробелов из символьных строк, пользоваться именно
этими преобразованными значениями в программе нередко удобнее, чем значениями непосредствен-
но из массива $_POST. Для этого достаточно составить в функции проверки достоверности массив
из преобразованных значений для последующей их обработки, как показано в примере 7.13.
*/

Пример 7.13. Составление массива из преобразованных входных данных

function validate_form() {
	$errors = array();
	$input = array();

	$input['age'] = filter_input (INPUT_POST, 'age', FILTER_VALIDATE_INT);
	if (is_null($input['age']) || ($input['age'] === false)) {
		$errors[] = 'Please enter a valid age.';
	}

	$input['price'] = filter_input(INPUT_POST, 'price', FILTER_VALIDATE_FLOAT);
	if (is_null($input['price']) || ($input['price'] === false)) {
		$errors[] = 'Please enter a valid price.';
	}

	// воспользоваться нулеобъединяющей операцией, если
	// значение в элементе $_POST['name'] не установлено
	$input['name'] = trim($_POST['name') ?? '');
	// ?? ''  - нулеобъединяющая операция 
	if (strlen($input['name']) == 0) {
		$errors[] = "Your name is required.";
	}

	return array($errors, $input);
}

/*
В функции validate_form() из примера 7.13 массив $input составляется из значений по ме-
ре их проверки. В ней также создается массив $errors, если возникают какие-нибудь ошибки. Как
только эти массивы будут созданы, их необходимо возвратить, чтобы в остальной части программы
можно было воспользоваться не только массивом $errors, но и массивом $input. С этой целью
они связываются вместе в двухэлементный массив, который и возвращается.
Если функция validate_form() возвращает как входные данные, так и ошибки, вызывающий
ее код должен быть видоизменен, чтобы учесть это обстоятельство. В примере 7.14 демонстрируется
видоизмененный вариант начальной части кода из примера 7.8, где обрабатываются оба массива,
возвращаемых функцией validate_form().
*/

list();

/*
list() - Подобно array(), это не функция, а языковая конструкция. list() используется для того, 
чтобы присвоить списку переменных значения за одну операцию.
Замечание:

До PHP 7.1.0, list() работала только с индексированными массивами и принимала числовые индексы начиная с 0.

Внимание
В PHP 5 list() присваивает значения начиная с самого правого. В PHP 7 list() - с самого левого.

Если вы используете обычные переменные, можете не думать об этом, но, если вы используете массивы с индексами, 
вы ожидаете, что порядок элементов в массиве будет ровно таким, как вы его определили в list(), слева направо, 
но в PHP 5 вы получите обратный порядок.

Вообще говоря, желательно не полагаться на конкретный порядок операций, так как в будущем это поведение может 
быть изменено.

<?php

$info = array('кофе', 'коричневый', 'кофеин');

// Составить список всех переменных
list($drink, $color, $power) = $info;
echo "$drink - $color, а $power делает его особенным.\n";

// Составить список только некоторых из них
list($drink, , $power) = $info;
echo "В $drink есть $power.\n";

// Или пропустить все, кроме третьей
list( , , $power) = $info;
echo "Мне нужен $power!\n";

// list() не работает со строками
list($bar) = "abcde";
var_dump($bar); // NULL
?>
*/

Пример 7.14. Обработка ошибок и видоизмененных входных данных
// Логика выполнения верных действий на
// основании метода запроса
if ($_SERVER['REQUEST_METHOD'] == 'POST') {
	// Если функции validate_form() возвращает ошибки,
	// передать их функции show_form()
	list($form_errors, $input) = validate_form();
	if ($form_errors) {
		show_form($form_errors);
	} else {
		process_form($input);
	}
} else {
	show_form() ;
}


/*
Конструкция list() применяется в коде из примера 7.14 для того, чтобы деструктурировать
значение, возвращаемое из функции validate_form(). Как известно, функция validate_form()
будет всегда возвращать массив с двумя элементами, первый из которых может оказаться пустым
массивом сообщений об ошибок, а второй — массивом видоизмененных входных данных, и поэто-
му в конструкции list($form_errors, $input) интерпретатору РНР указывается присвоить
первый элемент этого возвращаемого массива переменной $form_errors, а второй элемент — пе-
ременной $input. Наличие этих массивов в отдельных переменных упрощает чтение исходного
кода.
После обработки возвращаемых массивов надлежащим образом применяется аналогичная логи-
ка. Если массив $errors оказывается непустым, вызывается функция show_form() с массивом
$errors в качестве аргумента. В противном случае вызывается функция обработки формы. Един-
ственное отличие заключается в том, что теперь функции обработки формы передается массив видо-
измененных значений для последующего применения. Это означает, что функция process_form()
теперь должна обращаться к элементу массива $input[’my_name’], а не к элементу массива
$_POST['my_name'] для поиска выводимых на экран значений.
*/

Диапазоны чисел
/*
Чтобы проверить, находится ли число в определенном диапазоне, следует воспользоваться вари-
антами min_range и max_range выбора фильтра FILTER_VALIDATE_INT. Эти варианты выбора
передаются в качестве четвертого аргумента функции filter_input(), как показано в примере
7.15.
*/

Пример 7.15. Проверка целочисленного диапазона
$input['age'] = filter_input(INPUT_POST, 'age', FILTER_VALIDATE_INT, array(
	'options' => array(
		'min_range' => 18,
		'max_range' => 65
	)));
if (is_null($input['age']) || ($input['age'] === false)) {
	$errors[] = 'Please enter a valid age between 18 and 65.';
}

/*
Обратите внимание на то, что в качестве четвертого аргумента функции filter_input() пере-
даются не сами варианты выбора фильтра, а одноэлементный массив с ключом options и значением
из конкретного массива вариантов выбора и их значений. В фильтре FILTER_VALIDATE_FLOAT не
поддерживаются варианты выбора min_range и max_range, и поэтому сравнивать их необходимо
самостоятельно, как показано ниже.
*/

$input['price'] = filter_input(INPUT_POST, 'price', FILTER_VALIDATE_FLOAT);
if (is_null($input['price']) || ($input['price'] === false) ||
($input['price'] < 10.00) || ($input['price'] > 50.00)) {
$errors[] = 'Please enter a valid price between $10 and $50.';
}

/*
Чтобы проверить диапазон дат, переданное значение даты следует сначала преобразовать в объ-
ект типа DateTime, а затем проверить достоверность этого значения (подробнее об объектах типа
DateTime и функциях checkdate(), применяемых в примере 7.16, см. в главе 15). Объекты типа
DateTime инкапсулируют всю информацию, необходимую для представления момента времени, и
поэтому для применения диапазона, охватывающего месяц или год, не требуется предпринимать
ничего особенного. Так, в примере 7.16 проверяется, относится ли предоставляемая дата к моменту
времени менее чем шестимесячной давности.
*/

Пример 7.16. Проверка диапазона дат
// создать объект типа DateTime с датой шестимесячной давности
$range_start = new DateTime('6 months ago');
// создать объект типа DateTime с текущей датой
$range_end = new DateTime();
// в элементе массива $_POST['year'] хранится год, состоящий из четырех цифр;
// в элементе массива $_POST['month'] хранится месяц, состоящий из двух цифр;
// в элементе массива $_POST['day'] хранится день, состоящий из двух цифр
$input['year'] = filter_input(INPUT_POST, 'year', FILTER_VALIDATE_INT,
array('options' => array(
	'min_range' => 1900,
	'max_range' => 2100
)));
$input['month'] = filter_input(INPUT_POST, 'month', FILTER_VALIDATE_INT,
array('options' => array(
	'min_range' => 1,
	'max_range' => 12
)));
$input['day'] = filter_input(INPUT_POST, 'day', FILTER_VALIDATE_INT,
array('options' => array(
	'min_range' => 1,
	'max_range' => 31
)));
// Для сравнения с логическим значением false операция ===
// не требуется, т.к. нулевое значение является недопустимым
// вариантом выбора года, месяца или дня. В функции checkdate()
// проверяется допустимое количество дней в данном месяце и году
if ($input['year'] && input ['month'] && input['day'] &&
checkdate($input['month'], $input['day'], $input['year'])) {
	$submitted_date = new DateTime(strtotime(
	$input['year'] . '-' .
	$input['month'] . '-' .
	$input['day']));
	if (($range_start > $submitted_date) || ($range_end < $submitted_date)) {
		$errors[] = 'Please choose a date less than six months old.';
	}
} else {
	// Это сообщение выводится в том случае, если пользователь
	// пропустит один из параметров или введет в форме дату
	// вроде 31 февраля
	$errors[] = 'Please enter a valid date.';
}

Адреса электронной почты
/*
Безусловно, проверка адреса электронной почты является самой распространенной формой про-
верки достоверности данных из формы. Но для проверки достоверности адреса электронной почты
за один раз идеального способа не существует, поскольку “достоверность” означает совершенно раз-
ное в зависимости от преследуемой цели. Если действительно требуется убедиться, что пользователь
предоставил рабочий адрес электронной почты и что он контролирует этот адрес, необходимо сде-
лать следующее. Во-первых, отправить сообщение, содержащее произвольную символьную строку
по переданному в форме адресу электронной почты. В этом сообщении можно предложить поль-
зователю передать произвольную символьную строку в форме на веб-сайт, где она должна быть
обработана. И во-вторых, можно включить в сообщение URL, на котором пользователю достаточно
щелкнуть и который содержит встроенный код. Если код передан (или произведен щелчок на URL),
значит, пользователь получил сообщение и контролирует адрес электронной почты, переданный в
форме на веб-сайт, где она должна быть обработана, или, по крайней мере, он знает о передаче и
подтверждает ее.
Если нет желания брать на себя все хлопоты, связанные с проверкой достоверности адреса
электронной почты с помощью отдельного сообщения, можно ограничиться простой синтаксиче-
ской проверкой в коде, проверяющем достоверность данных в форме, чтобы искоренить неверно
набранные адреса. В частности, фильтр FILTER_VALIDATE_EMAIL проверяет символьные строки
по правилам для допустимых адресов электронной почты, как показано в примере 7.17.
*/

Пример 7.17. Проверка синтаксиса адреса электронной почты
$input['email'] = filter_input(INPUT_POST, 'email', FILTER_VALIDATE_EMAIL);
if (! $input['email']) {
	$errors[] = 'Please enter a valid email address';
}

/*
Упрощенная проверка if (! $input['email']) оказывается пригодной в коде из примера
7.17 потому, что любые переданные на обработку символьные строки, которые вычисляются как
ложные (например, пустая или нулевая строка), также считаются недопустимыми адресами элек-
тронной почты.



Списки, размечаемые дескриптором <select>
Когда в форме употребляется список, размечаемый дескриптором <select>, необходимо убе-
диться, что переданное на обработку значение элемента такого списка разрешено для выбора. И
хотя пользователь не может переделать значение вне данного списка, используя типичный, правиль-
но работающий браузер вроде Firefox или Chrome, атакующий злоумышленник способен составить
запрос, содержащий произвольное значение, не пользуясь браузером.
Чтобы упростить отображение и проверку достоверности списков, размечаемых дескриптором
<select>, следует ввести варианты выбора из списка в массив, а затем перебрать массив для
отображения такого списка в теле функции show_form(). Для проверки переданного на обработку
значения можно воспользоваться тем же самым массивом, что и в функции validate_form().
В примере 7.18 показано, как отображать подобным способом список, размечаемый дескриптором
<select>.
*/

Пример 7.18. Отображение списка, размечаемого дескриптором <select>

$sweets = array('Sesame Seed Puff', 'Coconut Milk Gelatin Square',
'Brown Sugar Cake','Sweet Rice and Meat');
function generate_options($options) {
	$html = '';
	foreach ($options as $option) {
		$html .= "<option>$option</option>\n";
	}
	return $html;
}
// отобразить форму
function show_form() {
$sweets = generate_options($GLOBALS['sweets']);
print<<<_HTML_
<form method="post" action="$_SERVER[PHP_SELF]">
Your Order: <select name="order">
$sweets
</select>
<br/>
<input type="submit" value="Order">
</form>
_HTML_;
}

/*
Массив вариантов выбора из списка, размечаемого дескриптором <select>, применяется в теле
функции validate_form() аналогично следующему:
*/

$input['order'] = $_POST['order'];
if (! in_array($input['order'], $GLOBALS['sweets'])) {
	$errors[] = 'Please choose a valid order.';
}

/*
Если нужно составить список, размечаемый дескриптором <select>, из разных вариантов выбора 
элементов и их значений, то потребуется более сложный массив. В этом случае ключ к каждому
элементу массива является атрибутом value для одного элемента списка, а соответствующим зна-
чением элемента массива — отображаемый вариант выбора данного элемента списка. В примере 7.19
значениями элементов списка являются следующие величины: puff, square, cake и ricemeat,
а отображаемыми вариантами выбора — Sesame Seed Puff, Coconut Milk Gelatin Square,
Brown Sugar Cake и Sweet Rice and Meat.
*/


Пример 7.19. Список, размечаемый дескриптором <select>, с разными вариантами выбора и
значениями элементов

$sweets = array(
	'puff' => 'Sesame Seed Puff',
	'square' => 'Coconut Milk Gelatin Square',
	'cake' => 'Brown Sugar Cake',
	'ricemeat' => 'Sweet Rice and Meat'
);
function generate_options_with_value ($options) {
	$html = '';
	foreach ($options as $value => $option) {
		$html .= "<option value=$value>$option</option>";
	}
	return $html;
}
// отобразить форму
function show_form() {
$sweets = generate_options_with_value($GLOBALS['sweets']);
print<<<_HTML_
<form method="post" action="$_SERVER[PHP_SELF]">
Your Order: <select name="order">
$sweets
</select>
<br/>
<input type="submit" value="Order">
</form>
_HTML_;
}

/*
Из списка, размечаемого дескриптором <select> в примере 7.19, на обработку должно быть пе-
редано одно из следующих значений: puff, square, cake или ricemeat. В примере 7.20 показано,
как переданное на обработку значение проверяется на достоверность в функции validate_form().
*/

Пример 7.20. Проверка достоверности значения, передаваемого на обработку из списка, разме-
чаемого дескриптором <select>

$input['order'] = $_POST['order'];
if (! array_key_exists($input['order'] , $GLOBALS['sweets'])) {
	$errors[] = 'Please choose a valid order.';
}




HTML и JavaScript (стр. 145)
/*
В языке РНР предоставляются две функции: 
функция strip_tags() удаляет дескрипторы HTML-разметки из символьной строки,
функция htmlentities() кодирует специальные символы HTML-разметки. 
Применение функции strip_tags() демонстрируется в примере 7.21.
*/

Пример 7.21. Очистка символьной строки от дескрипторов HTML-разметки
// удалить дескрипторы HTML-разметки из комментариев
$comments = strip_tags($_POST['comments']);
// а теперь вывести содержимое переменной $comments на экран
print $comments;

/*
Если элемент массива $_POST['comments'] содержит следующую информацию:
I
<b>love</b> sweet <div
class="fancy">rice</div> &
tea.
при выполнении кода из примера 7.21 на экран выводится следующий результат:
I love sweet rice & tea.

Все дескрипторы HTML-разметки и их атрибуты удаляются, не затрагивая заключенный в них
простой текст. 

Функция strip_tags() очень удобна, но она неверно обрабатывает непарные знаки
< и >. Например, исходную строку "I <3 Monkeys" она преобразует в строку "I ". Эта функция
начинает очистку, как только обнаружит знак <, не останавливаясь на этом, даже если отсутствует
соответствующий знак >.

Зачастую лучшие результаты дает кодирование вместо очистки дескрипторов. В примере 7.22
демонстрируется кодирование с помощью функции htmlentities().
*/

Пример 7.22. Кодирование HTML-представлений символов в строке
$comments = htmlentities($_POST['comments']);
// Теперь содержимое переменной $comments можно вывести на экран
print $comments;

/*
Если элемент массива $_POST['comments'] содержит следующее:
I
<b>love</b> sweet <div
class="fancy">rice</div> &
tea
то при выполнении кода из примера 7.22 на экран выводится такой результат:
I &lt;b&gt;love&lt;/b&gt; sweet &lt;div class=&quot;fancy
&quot;&gt;rice&lt;/div&gt; &amp; tea.


А если элемент массива $_POST['comments'] содержит следующее:
I
<b>love</b> sweet <div
class="fancy">rice</div> &
tea
то при выполнении кода из примера 7.22 на экран выводится такой результат:
I &lt;b&gt;love&lt;/b&gt; sweet &lt;div class=&quot;fancy
&quot;&gt;rice&lt;/div&gt; samp; tea.

Таким образом, символы, имеющие особое назначение в HTML-разметке (<, >, & и "), изменены
на следующие эквиваленты их представлений:
• знак < на HTML-представление &lt;
• знак > на HTML-представление &gt;
• знак & на HTML-представление &amp;
• знак " на HTML-представление &quot;
*/


Отображение значений, устанавливаемых по умолчанию
/*
Иногда требуется отобразить форму со значением, которое уже находится в текстовом поле или
предварительно установлено во флажках, кнопках-переключателях или элементах выбора из спис-
ка, размечаемого дескриптором <select>. Кроме того, при повторном отображении формы из-за
ошибок ее заполнения полезно сохранить любую информацию, которую пользователь уже ввел. В
примере 7.23 приведен код, предназначенный для этой цели.
*/

Пример 7.23. Построение массива значений, устанавливаемых по умолчанию
if ($_SERVER['REQUEST_METHOD'] == 'POST') {
$defaults = $_POST;
} else {
$defaults = array(
	'delivery' => 'yes',
	'size' => 'medium',
	'main_dish' => array(
		'taro',
		'tripe'
	),
	'sweet' => 'cake');
}

/*
Если элемент массива $_SERVER['REQUEST_METHOD'] содержит метод POST, это означает, что
форма передана. В таком случае устанавливаемые по умолчанию значения должны происходить из
тех данные, которые передал пользователь. В противном случае можно установить свои значения
по умолчанию. Для большинства параметров формы устанавливаемым по умолчанию значением
является символьная строка или число. А в тех элементах формы, у которых имеется не одно зна-
чение, устанавливаемое по умолчанию значение может быть массивом. Характерным тому примером
служит список main_dish, размечаемый дескриптором <select> и состоящий из многозначных
элементов.
После установки значений по умолчанию следует предоставить подходящее значение из мас-
сива $defaults при выводе на экран дескриптора HTML-разметки соответствующего элемента
формы. Напомним, что устанавливаемые по умолчанию значения следует при необходимости зако-
дировать с помощью функции htmlentities(), чтобы предотвратить атаки типа межсайтового
выполнения сценариев. А структура дескрипторов HTML-разметки требует по-разному интерпрети-
ровать текстовые поля, списки, размечаемые дескриптором <select>, текстовые области, флажки
и кнопки-переключатели.
Так, для разметки текстовых полей следует установить значение соответствующего элемента из
массива $defaults в атрибуте value дескриптора <input>. В примере 7.24 показано, как это
делается.
*/

Пример 7.24. Установка значения по умолчанию в текстовом поле
print '<input type="text" name="my_name" value="' . htmlentities($defaults['my_name']). '">';

/*
А для разметки многострочных текстовых полей значение, закодированное HTML-представлением,
следует установить между дескрипторами <textarea> и </textarea>, как показано в примере 7.25.
*/

Пример 7.25. Установка значения по умолчанию в многострочной текстовой области
print '<textarea name="comments">';
print htmlentities($defaults['comments']);
print '</textarea>';

/*
Для разметки списков дескриптором <select> следует ввести проверку в цикл, выводящий на
экран дескрипторы <option>, чтобы вывести атрибут selected, когда это уместно. В примере
7.26 приведен код, выполняющий эти действия для списка, размечаемого дескриптором <select>.
*/

Пример 7.26. Установка значения по умолчанию в списке, размечаемого дескриптором <select>

$sweets = array(
	'puff' => 'Sesame Seed Puff',
	'square' => 'Coconut Milk Gelatin Square',
	'cake' => 'Brown Sugar Cake',
	'ricemeat' => 'Sweet Rice and Meat'
);
print '<select name="sweet">';
// Знак > обозначает значение элемента выбора,
// а переменная $lаbеl — отображаемый элемент списка
foreach ($sweets as $option => $label) {
	print '<option value="' .$option . '"';
	if ($option == $defaults['sweet']) {
	print ' selected';
	}
	print "> $label</option>\n";
}
print '</select>';

/*
Чтобы установить значения по умолчанию в списке, размечаемом дескриптором <select> и
состоящем из с многозначных элементов, необходимо преобразовать массив устанавливаемых по
умолчанию значений в ассоциативный массив, в котором каждый ключ обозначает выбираемый ва-
риант выбора. Затем следует вывести атрибут selected для элементов списка, находящихся в
данном ассоциативном массиве. В примере 7.27 показано, как это делается.
*/

Пример 7.27. Установка значений по умолчанию в списке, размечаемом дескриптором <select>
и состоящем из многозначных элементов

$main_dishes = array(
	'cuke' => 'Braised Sea Cucumber',
	'stomach' => "Sauteed Pig's Stomach",
	'tripe' => 'Sauteed Tripe with Wine Sauce',
	'taro' => 'Stewed Pork with Taro',
	'giblets' => 'Baked Giblets with Salt',
	'abalone' => 'Abalone with Marrow and Duck Feet'
);
print '<select name="main_dish[]" multiple>';
$selected_options = array();
foreach ($defaults['main_dish') as $option) {
$selected_options[$option] = true;
}
// вывести дескрипторы <option>
foreach ($main_dishes as $option => $label) {
	print '<option value="' . htmlentities($option) . '"';
	if (array_key_exists($option, $selected_options)) {
		print ' selected';
	}
	print '>' . htmlentities($label) . '</option>';
}
print '</select>';

/*
Для разметки флажков и кнопок-переключателей дескриптор <input> дополняется атрибутом
checked. Синтаксис разметки флажков и кнопок-переключателей отличается лишь значением 
атрибута type. Так, в примере 7.28 на экран выводится устанавливаемый по умолчанию флажок
delivery и три кнопки-переключателя size с разными значениями, устанавливаемыми по умол-
чанию.
*/

Пример 7.28. Установка значений по умолчанию в кнопках-переключателях и флажках

print '<input type="checkbox" name="delivery" value="yes"';
if ($defaults['delivery'] == 'yes') { print ' checked'; }
print '> Delivery?';
$checkbox_options = array(
	'small' => 'Small',
	'medium' => 'Medium',
	'large' => 'Large'
);
foreach ($checkbox_options as $value => $label) {
	print '<input type="radio" name="size" value="'.$value. '"';
	if ($defaults['size'] == $value) { print ' checked'; }
	print "> $label ";
}

Собирая все вместе
/*
Превращение скромной веб-формы в полноценное веб-приложение с проверкой достоверности
данных, выводом на экран устанавливаемых по умолчанию значений и обработкой переданных
результатов может оказаться непростой задачей. Чтобы облегчить решение такой задачи, в этом
разделе представлен пример законченной программы, выполняющей следующие действия.
• Отображение формы с устанавливаемыми по умолчанию значениями.
• Проверка достоверности данных, переданных из формы на обработку.
• Повторное отображение формы с сообщениями об ошибках и сохраненными данными, введен-
ными пользователем, если переданные на обработку данные недостоверны.
• Обработка переданных на обработку данных, если они достоверны.
Данный пример законченной программы основан на классе, содержащем ряд вспомогательных
методов, чтобы упростить отображение и обработку элементов заполняемой формы. Исходный код
этого класса приведен в примере 7.29.
*/

Пример 7.29. Вспомогательный класс для отображения и обработки элементов заполняемой
формы
class FormHelper {
	protected $values = array();

	public function __construct($values = array()) {
		if ($_SERVER['REQUEST_METHOD'] == 'POST') {
			$this->values = $_POST;
		} else {
			$this->values = $values;
		}
	}

	public function input($type, $attributes = array(), $isMultiple = false) {
		$attributes['type'] = $type;
		if (($type == 'radio') || ($type == 'checkbox')) {
			if ($this->isOptionSelected($attributes['name'] ?? null, $attributes['value'] ?? null)) {
				$attributes['checked'] = true;
			}
		}
		return $this->tag('input', $attributes, $isMultiple);
	}

	public function select($options, $attributes = array()) {
		$multiple = $attributes['multiple'] ?? false;
		return $this->start('select', $attributes, $multiple) . $this->options($attributes['name'] ?? null, $options) . $this->end('select');
	}

	public function textarea($attributes = array()) {
		$name = $attributes['name'] ?? null;
		$value = $this->values[$name] ?? '';
		return $this->start('textarea', $attributes) . htmlentities($value) . $this->end('textarea');
	}

	public function tag($tag, $attributes = array(), $isMultiple = false) {
		return "<$tag {$this->attributes($attributes, $isMultiple)} />";
	}

	public function start($tag, $attributes = array(), $isMultiple = false) {
		// Дескрипторы <select> и <textarea> не получают атрибуты value
		$valueAttribute = (! (($tag == 'select')||($tag == 'textarea')));
		$attrs = $this->attributes($attributes, $isMultiple, $valueAttribute);
		return "<$tag $attrs>";
	}

	public function end($tag) {
		return "</$tag>";
	}

	protected function attributes($attributes, $isMultiple, $valueAttribute = true) {
		$tmp = array();
		// Если данный дескриптор может содержать атрибут value,
		// а его имени соответствует элемент в массиве значений,
		// то установить этот атрибут
		if ($valueAttribute && isset($attributes['name']) && array_key_exists($attributes['name'], $this->values)) {
			$attributes['value'] = $this->values[$attributes['name']];
		}
		foreach ($attributes as $k => $v) {
			// Истинное логическое значение означает
			// логический атрибут
			if (is_bool($v)) {
				if ($v) { $tmp[] = $this->encode($k); }
			}
			// иначе k = v
			else {
				$value = $this->encode($v);
				// Если это многозначный элемент, присоединить
				// квадратные скобки ([]) к его имени
				if ($isMultiple && ($k == 'name')) {
				$value .= '[]';
				}
				$tmp[] = "$k=\"$value\"";
			}
		}
		return implode(' ', $tmp);
	}

	protected function options($name, $options) {
		$tmp = array();
		foreach ($options as $k => $v) {
			$s = "<option value=\"{$this->encode($k)}\"";
			if ($this->isOptionSelected($name, $k)) {
				$s .= ' selected';
			}
			$s .= ">{$this->encode($v)}</option>";
			$tmp[] = $s;
		}
		return implode('', $tmp);
	}

	protected function isOptionSelected($name, $value) {
		// Если для аргумента $name в массиве отсутствует
		// элемент, значит, этот элемент нельзя выбрать
		if (! isset($this->values[$name])) {
			return false;
		}
		// Если же для аргумента $name в массиве имеется
		// элемент, который сам является массивом, проверить,
		// находится значение аргумента $value в массиве
		else if (is_array($this->values[$name])) {
			return in_array($value, $this->values[$name]);
		}
		// А иначе сравнить значение аргумента $value с
		// элементом массива значений по значению аргумента $name
		else {
			return $value == $this->values[$name];
		}
	}

	public function encode($s) {
		return htmlentities($s);
	}
}

/*
В методах из класса, приведенного в примере 7.29, внедрена логика, обсуждавшаяся ранее в
разделе “Отображение значений, устанавливаемых по умолчанию” для отдельных видов элементов
заполняемой формы. В исходном коде формы, приведенном в примере 7.30, применяются разные
элементы, и поэтому код их отображения проще вынести в отдельные, повторно вызываемые функ-
ции, чтобы не дублировать его всякий раз, когда потребуется вывести отдельный элемент формы на
экран.
Конструктору класса FormHelper в качестве аргумента должен быть передан ассоциативный
массив значений, устанавливаемых по умолчанию. Если для запроса не выбран метод POST, то
данный массив используется для выявления подходящих значений по умолчанию. В противном
случае основанием для устанавливаемых по умолчанию значений служат переданные на обработку
данные.
В методе input() из класса FormHelper формируется соответствующая HTML-разметка для
любого элемента ввода данных в форме. В качестве первого аргумента этому методу передает-
ся тип элемента заполняемой формы (например, submit, radio или text), а в качестве вто-
рого необязательного аргумента — ассоциативный массив атрибутов элемента формы (например,
['name' => 'meal']). И, наконец, в качестве третьего необязательного аргумента данному методу
передается логическое значение true, если формируется HTML-разметка многозначного элемента
формы, например, флажка.
В методе select() формируется разметка списка дескриптором <select>. В качестве первого
аргумента этому методу передается массив элементов, выбираемых из списка, а в качестве второго
необязательного аргумента — ассоциативный массив атрибутов дескриптора <select>. Для раз-
метки списка с многозначными элементами дескриптором <select> следует включить пару “ключ-
значение” ’multiple’ => true в массив атрибутов, передаваемый данному методу в качестве
второго аргумента.
Метод textarea() формирует HTML-разметку текстовой области дескриптором <textarea>.
В качестве единственного аргумента он принимает ассоциативный массив атрибутов данного де-
скриптора.
Три упомянутых выше метода должны взять на себя всю работу по отображению формы. Но
если для ее разметки потребуются другие дескрипторы или специальная интерпретация имеющихся
дескрипторов, тогда можно воспользоваться методами tag(), start() и end().
В частности, метод tag() формирует HTML-разметку всего самозакрывающегося дескриптора
вроде <input/>. В качестве аргументов ему передаются имя дескриптора, необязательный массив
атрибутов и логическое значение true, если дескриптор может принимать несколько значений. Для
формирования надлежащей HTML-разметки в методе input() вызывается метод tag().
Методы start() и end() служат для формирования HTML-разметки элементов формы с
отдельными начальным и конечным дескрипторами. В частности, метод start() формирует на-
чальный дескриптор разметки элемента формы, принимая в качестве аргументов имя дескриптора,
атрибуты и признак многозначности элемента формы. А метод end() принимает в качестве ар-
гумента только имя дескриптора, возвращая закрывающий дескриптор HTML-разметки. Так, если
для HTML-разметки элемента формы применяется дескриптор <fieldset>, можно сделать вызов
start('fieldset',['name'=>'adjustments']), сформировать HTML-разметку набора полей, а
затем сделать вызов end('fieldset').
Остальная часть методов из класса FormHelper выполняет вспомогательную роль при форми-
ровании HTML-разметки и не предназначена для вызова за пределами данного класса. В частно-
сти, метод attributes() форматирует ряд атрибутов, чтобы ввести их надлежащим образом в
дескриптор HTML-разметки. Используя значения, устанавливаемые по умолчанию в объекте дан-
ного класса, этот метод вводит соответствующий атрибут value по мере надобности. Кроме того,
он присоединяет квадратные скобки ([]) к имени элемента, если этот элемент может принимать
несколько значений, а также обеспечивает надлежащее кодирование значений атрибутов HTML-
представлениями.
Метод options() выполняет форматирование дескрипторов <option> для разметки списка
дескриптором <select>. С помощью метода isOptionSelected() в нем выявляются те эле-
менты списка, которые должны быть помечены как выбранные (selected), а также выполняется
надлежащее кодирование значений атрибутов HTML-представлениями.
Метод encode() служит оболочкой для встроенного в РНР метода htmlentities(). Это
открытый (public) метод, поэтому его можно вызывать в исходном коде программы с целью обес-
печить согласованность кодирования HTML-представлениями.
Исходный код из примера 7.30 основан на классе FormHelper для отображения краткой фор-
мы заказа на приготовление трапезы. Если форма передана на обработку правильно, результаты ее
обработки отображаются в окне браузера и отправляются (предположительно шеф-повару, чтобы он
приступил к приготовлению заказанной еды) по адресу электронной почты, определяемому в функ-
ции process_form(). Код из данного примера входит и выходит из режима РНР, и поэтому он
начинается для большей ясности открывающим дескриптором <?php и оканчивается закрывающим
дескриптором ?>.
*/

Пример 7.30. Полноценная форма с отображением устанавливаемых по умолчанию значений,
проверкой достоверности и обработкой переданных данных


// Здесь предполагается, что исходный файл FormHelper.php
// находится в том же каталоге, где и данный файл
require 'FormHelper.php';
// Установить массивы с вариантами выбора из списка, размечаемого дескриптором <select>. Следующие массивы
// требуются в функциях display_form(), validate_form() и process_form(), и поэтому они объявляются в 
// глобальной области действия
$sweets = array(
	'puff' => 'Sesame Seed Puff',
	'square' => 'Coconut Milk Gelatin Square',
	'cake' => 'Brown Sugar Cake',
	'ricemeat' => 'Sweet Rice and Meat'
);

$main_dishes = array(
	'cuke' => 'Braised Sea Cucumber',
	'stomach' => "Sauteed Pig's Stomach",
	'tripe' => 'Sauteed Tripe with Wine Sauce',
	'taro' => 'Stewed Pork with Taro',
	'giblets' => 'Baked Giblets with Salt',
	'abalone' => 'Abalone with Marrow and Duck Feet'
);
// Основная логика функционирования страницы:
// - Если форма передана на обработку, проверить достоверность данных, обработать их и снова отобразить форму.
// - Если форма не передана на обработку, отобразить ее снова
if ($_SERVER['REQUEST_METHOD'] == 'POST') {
	// Если функция validate_form() возвратит ошибки,
	// передать их функции show_form()
	list($errors, $input) = validate_form();
	if($errors) {
		show_form($errors);
	} else {
	// Переданные данные из формы достоверны, обработать их
		process_form($input);
	}
} else {
// Данные из формы не переданы, отобразить ее снова
	show_fоrm();
}

function show_form($errors = array()) {
	$defaults = array('delivery' => 'yes', 'size' => 'medium');
	// создать объект $form с надлежащими свойствами по умолчанию
	$form = new FormHelper($defaults);
	// Ради ясности весь код HTML-разметки и отображения формы вынесен в отдельный файл
	include 'complete-form.php';
}

function validate_form() {
	$input = array();
	$errors = array();
	// обязательное имя
	$input['name'] = trim($_POST['name'] ?? '');
	if (! strlen($input['name'])) {
		$errors[] = 'Please enter your name.';
	}
	// обязательный размер блюда
	$input['size'] = $_POST['size'] ?? '';
	if (! in_array($input['size'], ['small','medium','large'])) {
		$errors[] = 'Please select a size.';
	}
	// обязательное сладкое блюдо
	$input['sweet'] = $_POST['sweet'] ?? '';
		if (! array_key_exists($input['sweet'], $GLOBALS['sweets'])) {
	$errors[] = 'Please select a valid sweet item.';
	}
	// два обязательных блюда
	$input['main_dish'] = $_POST['main_dish'] ?? array();
	if(count($input['main_dish']) != 2) {
		$errors[] = 'Please select exactly two main dishes.';
	} else {
		// Если выбрано два основных блюда, убедиться в их
		// достоверности
		if (! (array_key_exists($input['main_dish'][0], $GLOBALS['main_dishes']) &&
		array_key_exists($input['main_dish'][1], $GLOBALS['main_dishes']))) {
		$errors[] = 'Please select exactly two valid main dishes.';
		}
	}
	// Если выбрана доставка, то в комментариях должны быть
	// указаны ее подробности
	$input['delivery'] = $_POST['delivery'] ?? 'no';
	$input['comments'] = trim($_POST['comments'] ?? '');
	if (($input['delivery'] == 'yes') && (! strlen($input['comments']))) {
		$errors[] = 'Please enter your address for delivery.';
	}
	return array($errors, $input);
}

function process_form($input) {
	// найти полные наименования основных и сладких блюд
	// в массивах $GLOBALS['sweets'] и $GLOBALS['main_dishes']
	$sweet = $GLOBALS['sweets'][ $input['sweet'] ];
	$main_dish_1 = $GLOBALS['main_dishes'][ $input['main_dish'][0] ];
	$main_dish_2 = $GLOBALS['main_dishes'][ $input['main_dish'][1] ];
	if (isset($input['delivery']) && ($input['delivery'] == 'yes')) {
		$delivery = 'do';
	} else {
		$delivery = 'do not';
	}

// составить текст сообщения с заказом трапезы
$message=<<<_ORDER_
Thank you for your order, {$input['name']}.
You requested the {$input['size']} size of $sweet,
$main_dish_1, and $main_dish_2.
You $delivery want delivery.
_ORDER_;

	if (strlen(trim($input['comments']))) {
		$message .= 'Your comments: '.$input['comments'];
	}
	// отправить сообщение шеф-повару
	mail('chef@restaurant.example.com', 'New Order', $message);
	// вывести сообщение на экран, но закодировать его любыми HTML-представлениями 
	// и преобразовать знаки перевода строки в дескрипторы <br/>
	print nl2br(htmlentities($message, ENT_HTML5));
}


/*
nl2br — Вставляет HTML-код разрыва строки перед каждым переводом строки
nl2br ( string $string [, bool $is_xhtml = TRUE ] ) : string
Возвращает строку string, в которой перед каждым переводом строки (\r\n, \n\r, \n и \r) вставлен <br /> или <br>.

Список параметров 
string
Входная строка.

is_xhtml
Использовать ли совместимые с XHTML переводы строк или нет.
*/


// короткий echo-тег <?=, который является сокращением для более многословного <?php echo.

/*
Исходный код из примера 7.30 условно делится на четыре части: код из глобальной области действия, 
функции show_form(), validate_form() и process_form(). В глобальной области действия код решает 
три задачи. Сначала он загружает класс FormHelper из отдельного файла. Затем устанавливает два массива, 
в которых описываются варианты выбора из двух списков, размечаемых в форме дескриптором <select>. Эти 
массивы применяются в каждой из функций show_form(), validate_form() и process_form() и поэтому должны 
быть определены в глобальной области действия. И, наконец, код из глобальной области действия выполняет 
условный оператор if(), в котором принимается решение, что делать дальше: отображать, проверять на 
достоверность или обрабатывать форму.
Отображение формы осуществляет функция show_form(). Сначала она создает массив $defaults из значений 
по умолчанию. Затем этот массив передается конструктору класса FormHelper, а следовательно, во вновь 
создаваемом объекте $form данного класса устанавливаются нужные значения по умолчанию. Далее функция 
show_form() передает управление другому исходному файлу (complete-form.php), содержащему конкретный код 
HTML-разметки формы, а также код РНР ее отображения. Вынесение HTML-разметки в отдельный файл для такой 
крупной программы, как рассматриваемая в этом разделе, позволяет упростить ее усвоение, а также вносить 
изменения в оба файла независимо друг от друга. Содержимое исходного файла complete-form.php 
приведено в примере 7.31.

*/

<form method="POST" action="<?= $form->encode($_SERVER['PHP_SELF']) ?>">
	<table>
		<tr>
		<?php if ($errors) { ?>
			<td>You need to correct the following errors:</td>
			<td>
				<ul>
				<?php foreach ($errors as $error) { ?>
					<li><?= $form->encode($error) ?></li>
				<?php } ?>
				</ul>
			</td>
		<?php } ?>
		<tr>
			<td>Your Name:</td>
			<td><?= $form->input('text', ['name' => 'name']) ?></td>
		</tr>
		<tr>
			<td>Size: </td>
			<td>
				<?= $form->input('radio',['name' => 'size', 'value' => 'small']) ?> Small <br/>
				<?= $form->input('radio',['name' => 'size', 'value' => 'medium']) ?> Medium <br/>
				<?= $form->input('radio',['name' => 'size', 'value' => 'large']) ?> Large <br/>
			</td>
		</tr>
		<tr>
			<td>Pick one sweet item:</td>
			<td><?= $form->select($GLOBALS['sweets'], ['name' => 'sweet']) ?></td>
		</tr>
		<tr>
			<td>Pick two main dishes :</td>
			<td><?= $form->select($GLOBALS['main_dishes'], ['name' => 'main_dish', 'multiple' => true]) ?></td>
		</tr>
		<tr>
			<td>Do you want your order delivered?</td>
			<td><?= $form->input('checkbox',['name' => 'delivery', 'value' => 'yes']) ?> Yes </td>
		</tr>
		<tr>
			<td>Enter any special instructions.<br/>
			If you want your order delivered, put your address here:</td>
			<td><?= $form->textarea(['name' => 'comments']) ?></td>
	</tr>
		<tr>
			<td colspan="2" align="center"><?=$form->input('submit', ['value' => 'Order']) ?></td>
		</tr>
	</table>
</form>

/*
Код из исходного файла complete-form.php выполняется так, как будто он является частью
функции show_form(). Это означает, что такие локальные переменные, как, например, $errors
и $form, доступны из данной функции в исходном файле complete-form.php. И как все вклю-
чаемые файлы, исходный файл complete-form.php запускается вне любых дескрипторов РНР и
поэтому позволяет вывести на экран какую-нибудь HTML-разметку, а затем перейти в режим РНР,
если потребуется вызвать методы или воспользоваться логикой РНР. В данном коде в качестве со-
кращенного способа отображения результатов вызовов различных методов применяется короткий
эхо-дескриптор (<?=). Начало блока кода РНР с короткого эхо-дескриптора <?= равнозначно его
началу с дескриптора <php echo. Это удобно для HTML-разметки формы, поскольку различные
методы из класса FormHelper возвращают HTML-разметку, которая должна быть отображена.
В главном файле функция validate_form() создает массив сообщений об ошибках, если пе-
реданные данные из формы не удовлетворяют подходящим критериям. Следует, однако, иметь в
виду, что при проверках параметров size, sweet и main_dish выясняется не только, что именно
было передано в качестве их значений, но и достоверность значений отдельных параметров. Так,
для параметра size должно быть передано значение small, medium или large, а для парамет-
ров sweet и main_dish — ключи из глобальных массивов $sweets и $main_dishes. И хотя
рассматриваемая здесь форма содержит устанавливаемые по умолчанию значения, входные данные
все же целесообразно проверять на достоверность. Пытаясь взломать веб-сайт с данной формой,
кто-нибудь может в обход обычного браузера составить запрос с произвольным значением, не от-
носящимся к числу допустимых для выбора в списке, размечаемом дескриптором <select>, или в
группе кнопок-переключателей.
*/
?>