//Декораторы и переадресация вызова, call/apply

/*
JavaScript предоставляет исключительно гибкие возможности по работе с функциями: 
они могут быть переданы в другие функции, использованы как объекты, и сейчас мы 
рассмотрим, как перенаправлять вызовы между ними и как их декорировать.
*/

//Прозрачное кеширование
/*
Представим, что у нас есть функция slow(x), выполняющая ресурсоёмкие вычисления, 
но возвращающая стабильные результаты. Другими словами, для одного и того же x 
она всегда возвращает один и тот же результат.

Если функция вызывается часто, то, вероятно, мы захотим кешировать (запоминать) 
возвращаемые ею результаты, чтобы сэкономить время на повторных вычислениях.

Вместо того, чтобы усложнять slow(x) дополнительной функциональностью, мы заключим 
её в функцию-обёртку – «wrapper» (от англ. «wrap» – обёртывать), которая добавит 
кеширование. Далее мы увидим, что в таком подходе масса преимуществ.
*/

function slow(x) {
	// здесь могут быть ресурсоёмкие вычисления
	console.log(`Called with ${x}`);
	return x;
};

function chachingDecorator(func) {
	let cache = new Map();
	return function (x) {
		if(cache.has(x)) {      // если кеш содержит такой x,
			return cache.get(x);  // читаем из него результат
		}

		let result = func(x);   // иначе, вызываем функцию

		cache.set(x, result);   // и кешируем (запоминаем) результат
		return result;
	}
}

slow = chachingDecorator(slow);

console.log(slow(1))        // slow(1) кешируем
console.log( "Again: " + slow(1) ); // возвращаем из кеша

console.log( slow(2) );     // slow(2) кешируем
console.log( "Again: " + slow(2) ); // возвращаем из кеша


//При передаче методов объекта в качестве колбэков, например для setTimeout, 
//возникает известная проблема – потеря this
//https://learn.javascript.ru/bind

let user = {
  firstName: "Вася",
  sayHi() {
    console.log(`Привет, ${this.firstName}!`);
  }
};

//setTimeout(user.sayHi, 1000); // Привет, undefined!

let f = user.sayHi;
setTimeout(f, 1000); // контекст user потеряли

//Решение 1: сделать функцию-обёртку
setTimeout(function() {
	user.sayHi();
}, 1000);

//То же самое, только короче:
setTimeout(() => user.sayHi(), 1000);

//Выглядит хорошо, но теперь в нашем коде появилась небольшая уязвимость.

//Что произойдёт, если до момента срабатывания setTimeout (ведь задержка 
//составляет целую секунду!) в переменную user будет записано другое значение? 
//Тогда вызов неожиданно будет совсем не тот!

// ...в течение 1 секунды
user = { sayHi() { console.log("Другой пользователь в 'setTimeout'!"); } };

setTimeout(() => user.sayHi(), 1000);

//Решение 2: привязать контекст с помощью bind
//В современном JavaScript у функций есть встроенный метод bind, 
//который позволяет зафиксировать this.
//Базовый синтаксис bind:

// полный синтаксис будет представлен немного позже
//let boundFunc = func.bind(context);
//Результатом вызова func.bind(context) является особый «экзотический объект» 
//(термин взят из спецификации), который вызывается как функция и прозрачно 
//передаёт вызов в func, при этом устанавливая this=context.

//Другими словами, вызов boundFunc подобен вызову func с фиксированным this.

//Например, здесь funcUser передаёт вызов в func, фиксируя this=user:

let user2 = {
	firstName: 'Vasya'
}

function func() {
	console.log(this.firstName);
}

func(); //undefined

let funcUser = func.bind(user2);

funcUser();

//Здесь func.bind(user) – это «связанный вариант» func, с фиксированным this=user.