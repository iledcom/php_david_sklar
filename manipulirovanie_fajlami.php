<?php

Чтение и запись всего содержимого файлов

/*
Чтение из файла
Чтобы прочитать содержимое файла в символьную строку, следует вызвать функцию file_get_contents(), 
передав ей имя файла. Эта функция возвратит символьную строку, содержащую все,
что находится в данном файле. Так, в примере 9.2 содержимое файла из примера 9.1 сначала 
читается с помощью функции file_get_contents() и затем видоизменяется с помощью функции
str_replace(), а полученный результат выводится на экран.
*/

Пример 9.1. Содержимое файла раgе-template.html, используемого в примере 9.2

/*
<html>
	<head><title>{раgе_title}</title></head>
	<body bgcolor="{color}">
		<h1>Hello, {name}</h1>
	</body>
</html>
*/
Пример 9.2. Чтение, видоизменение и вывод шаблона страницы на экран
// загрузить файл шаблона из предыдущего примера
$раgе = file_get_contents('раgе-template.html');
// ввести заглавие страницы
$раgе = str_replace('{раgе_title}', 'Welcome', $раgе);
// окрасить страницу голубым цветом после полудня и
// зеленым цветом с утра
if (date('Н' >= 12)) {
	$раgе = str_replace('{color}', 'blue', $раgе);
} else {
	$раgе = str_replace('{color}', 'green', $раgе);
}
// взять имя пользователя из переменной сохраненного
// предыдущего сеанса
$раgе = str_replace('{name}', $_SESSION['username'], $раgе);
// вывести полученные результаты на экран
print $раgе;

Запись в файл
/*
Запись символьной строки в файл является противоположной операции чтения содержимого
файла в символьную строку. И для этой цели служит функция file_put_contents(), проти-
воположная по своему действию функции file_get_contents(). Пример 9.3 расширяет пример
9.2 сохранением HTML-разметки в файле вместо ее вывода на экран.
*/
Пример 9.3. Запись в файл с помощью функции file_put_contents()
// загрузить файл шаблона из предыдущего примера
$раgе = file_get_contents('раgе-template.html');
// ввести заглавие страницы
$раgе = str_replace('{раgе_title}', 'Welcome', $раgе);
// окрасить страницу голубым цветом после полудня и
// зеленым цветом с утра
if (date('H' >= 12)) {
$раgе = str_replace('{color}', 'blue', $раgе);
} else {
$раgе = str_replace('{color}', 'green', $раgе);
}
// взять имя пользователя из переменной сохраненного
// предыдущего сеанса
$раgе = str_replace('{name}', $_SESSION['username'], $раgе);
// записать полученные результаты в файл раgе.html
file_put_contents('раgе.html', $раgе);

/*
В коде из примера 9.3 содержимое переменной $раgе (т.е. HTML-разметка страницы) записывается
в файл page.html. В качестве первого аргумента функции file_put_contents() передается
имя файла, в который производится запись, а в качестве второго — записываемое содержимое.
*/

Частичное чтение и запись файлов
/*
Функции file_get_contents() и file_put_contents() удобны для манипулирования
сразу всем файлом. Но иногда требуется манипулировать лишь частью файла, и для этой цели служит 
функция file(), которая осуществляет доступ к отдельным строкам в файле. Так, в примере
9.4 демонстрируется чтение из файла, каждая строка которого содержит имя и адрес электронной
почты, а затем эта информация выводится на экран списком в формате HTML.
*/

Пример 9.4. Доступ к каждой строке в файле
foreach (file('people.txt') as $line) {
	$line = trim($line);
	$info = explode('|', $line);
	print '<li><a href="mailto:' . $info[0] . '">' . $info[1] ."</li>\n";
}

//Допустим, что в файле people.txt содержится текст, приведенный в примере 9.5.
Пример 9.5. Содержимое файла people.txt, применяемого в примере 9.4
alice@example.com|Alice Liddell
bandersnatch@example.org|Bandersnatch Gardner
charles@milk.example.com|Charlie Tenniel
dodgson@turtle.example.com|Lewis Humbert

//В таком случае при выполнении кода из примера 9.4 на экран выводится следующий результат:
<li><a href="mailto:alice@example.com">Alice Liddell</li>
<li><a href="mailto:bandersnatch@example.org">Bandersnatch Gardner</li>
<li><a href="mailto:charles@milk.example.com">Charlie Tenniel</li>
<li><a href="mailto:dodgson@turtle.example.com">Lewis Humbert</li>

/*
Функция file() возвращает массив. Каждый элемент этого массива представляет собой сим-
вольную строку, содержащую одну строку из файла, включая знак перевода строки. Поэтому в
цикле foreach() из примера 9.4 осуществляется перебор каждого элемента данного массива с
сохранением его символьной строки в переменной $line. В частности, функция trim() удаляет
конечный знак перевода строки, функция explode() разделяет строку на две части до и после
знака |, а оператор print выводит элементы списка в формате HTML.
Несмотря на все удобства функции file(), она не совсем подходит для манипулирования круп-
ными файлами. Ведь эта функция читает все содержимое файла для построения массива из про-
читанных строк, и если файл состоит из большого количества строк, то для их чтения может
потребоваться слишком много оперативной памяти. В таком случае содержимое крупного файла
придется читать построчно, как показано в примере 9.6.
*/

Пример 9.6. Чтение файла построчно
$fh = fopen('people.txt','rb');
while ((! feof($fh)) && ($line = fgets($fh))) {
	$line = trim($line);
	$info = explode('|', $line);
	print '<li><a href="mailto: ' . $info[0] . '">' . $info[1] ."</li>\n";
}
fclose($fh);

/*
В примере 9.6 применяются четыре функции доступа к файлу: fopen(), fgets(), feof() и
fclose(). Совместно они действуют следующим образом.
• Функция fopen() открывает файл и возвращает переменную, используемую для последую-
щего доступа к файлу в программе. (Принципиально это делается аналогично подключению
к базе данных с помощью операции new PDO(), возвращающей объект, сохраняемый в пере-
менной, как пояснялось в главе 8.)
• Функция fgets() читает строку из файла и возвращает ее в виде символьной строки.
• Интерпретатор РНР хранит закладку на текущую позицию в файле. Сначала эта закладка
делается на начало файла, и поэтому при первом вызове функции fgets() из файла читается
первая строка. После того как эта строка будет прочитана, закладка обновится, установившись
на начале следующей строки.
• Функция feof() возвращает логическое значение true, если закладка указывает на позицию
после конца файла (признак "eof" означает конец файла).
• Функция fclose() закрывает файл.
Цикл while() из примера 9.6 продолжает выполняться до тех пор, пока не произойдет одно из
двух:
• функция feof() возвратит логическое значение false;
• переменной $line будет присвоено значение, возвращаемое в результате вызова функции
fgets($fh) и вычисляемое как истинное (true).
Всякий раз, когда вызывается функция fgets($fh), интерпретатор РНР извлекает строку из
файла, продвигает свою закладку, иначе называемую дескриптором файла, и возвращает эту строку.
Если закладка указывает на самую последнюю позицию в файле, функция feof($fh) по-прежнему
возвращает логическое значение false. Но в то же время функция fgets($fh) возвращает логи-
ческое значение false, поскольку она пытается прочитать строку и не может этого сделать. Таким
образом, обе проверки этих возвращаемых значений необходимы для правильного завершения цикла.
В примере 9.6 применяется функция trim() для обработки значения переменной $line, по-
скольку символьная строка, возвращаемая функцией fgets(), содержит конечный знак перевода
строки. Функция trim() удаляет этот знак, чтобы усовершенствовать выводимый результат.
В качестве первого аргумента функции fopen() передается имя файла, к которому требуется
получить доступ. Как и при вызове остальных функций доступа к файлу, предоставляемых в РНР, в
данном случае следует использовать знак косой черты (/) вместо знака обратной косой черты (\) —
даже в Windows. В примере 9.7 демонстрируется, как открывается файл из каталога в ОС Windows.

Пример 9.7. Открытие файла в Windows
$fh = fopen('с:/windows/system32/settings.txt','rb');
Знаки обратной косой черты имеют особое назначение, экранируя специальные символы в стро-
ках, как пояснялось в разделе “Определение символьных строк текста” в главе 2. Поэтому в путях
к файлам проще пользоваться знаками косой черты. Они правильно распознаются интерпретатором
РНР при загрузке файлов в Windows.
В качестве второго аргумента функции fopen() передается режим доступа к файлу, опреде-
ляющий операции, которые разрешается выполнять над файлом: чтение, запись и т.д. Кроме того,
режим доступа к файлу определяет начальную позицию в файле, на которой интерпретатор РНР
делает закладку, порядок очистки содержимого файла при его открытии и способ реагирования
интерпретатора РНР на отсутствие файла. В табл. 9.1 перечислены различные режимы доступа к
файлу, которые распознает функция fopen().
*/

/*
Открыв файл в режиме доступа, разрешающем запись, можно воспользоваться функцией fwrite(),
чтобы записать какие-нибудь данные в файл. Так, в примере 9.8 используется режим доступа wb
вместе с функциями fopen() и fwrite() для записи информации, извлекаемой из таблицы базы
данных, в текстовый файл dishes.txt.
*/

Пример 9.8. Запись данных в файл
try {
 $db = new PDO('mysql:host=localhost; dbname=test_db', 'root', '');
} catch (Exception $e) {
print "Couldn't connect to database: " . $e->getMessage();
exit();
}
// открыть файл dishes.txt для записи
$fh = fopen('dishes.txt','wb');
$q = $db->query("SELECT dish_name, price FROM dishes");
while($row = $q->fetch()) {
// записать каждую строку (с завершающим знаком перевода
// строки) в файл dishes.txt
fwrite($fh, "The price of $row[0] is $row[1] \n");
}
fclose($fh);

/*
Функция fwrite() не добавляет автоматически знак перевода строки в конце записываемой в
файл символьной строки, а просто записывает именно то, что ей передается в качестве второго 
аргумента. Если же требуется дополнить знаком перевода строки каждую записываемую в файл строку,
как это делается в примере 9.8, в конце символьной строки, передаваемой функции fwrite(),
следует добавить знаки \n, обозначающие переход на новую строку.
*/

Манипулирование файлами формата CSV
/*
Особой интерпретации в РНР подлежат текстовые файлы формата CSV. Такие файлы не могут
содержать графики или диаграммы, но в то же время они позволяют обмениваться табличными
данными между разными программами. Чтобы прочитать строку из файла формата CSV, следует 
вызвать функцию fgetcsv() вместо fgets(). Эта функция читает строку из файла формата
CSV и возвращает массив, содержащий каждое поле в данной строке. Так, в примере 9.9 приведен
файл формата CSV, содержащий ресторанное меню, а в пример 9.10 демонстрируется применение
функции fgetcsv() для чтения файла и ввода полученной информации в таблицу базы данных,
упоминавшуюся в главе 8.

Пример 9.9. Содержимое файла dishes.csv
"Fish Ball with Vegetables",4.25,0
"Spicy Salt Baked Prawns",5.50,1
"Steamed Rock Cod",11.95,0
"Sauteed String Beans",3.15,1
"Confucius ""Chicken""",4.75,0
*/

Пример 9.10. Ввод данных формата CSV в таблицу базы данных
try {
	$db = new PDO('mysql:host=localhost; dbname=test_db', 'root', '');
} catch (Exception $e) {
	print "Couldn't connect to database: " . $e->getMessage();
exit();
}

$fh = fopen('dishes.csv','rb');

$stmt = $db->prepare('INSERT INTO dishes (dish_name, price, is_spicy) VALUES (?,?,?)');

while ((! feof($fh)) && ($info = fgetcsv($fh))) {
	// Элемент массива $info[0] содержит наименование блюда
	// из первого поля в строке, считанной из файла dishes.csv.
	// Элемент массива $info[1] содержит цену на блюдо
	// из второго поля в считанной строке.
	// Элемент массива $info[2] содержит состояние, обозначающее
	// наличие специй в блюде, из третьего поля в считанной строке.
	// Ввести упомянутое содержимое массива $info отдельной строкой
	// в таблицу базы данных
	$stmt->execute($info);
	print "Inserted $info[0]\n";
	}
	// закрыть файл
fclose($fh);

/*
Запись строки в файл формата CSV выполняется аналогично чтению из строки из такого файла.
С этой целью вызывается функция fputcsv(), принимающая в качестве аргументов дескриптор
файла и массив значений, заранее подготовленных в формате CSV для записи в файл. Так, в приме-
ре 9.11 демонстрируется применение функций fputcsv() и fopen() для записи в файл формата
CSV информации, извлекаемой из таблицы базы данных.
*/

Пример 9.11. Запись данных в файл формата CSV
try {
	$db = new PDO('mysql:host=localhost; dbname=test_db', 'root', '');
} catch (Exception $e) {
	print "Couldn't connect to database: " . $e->getMessage();
exit();
}

// открыть файл формата CSV для записи
$fh = fopen('dish-list.csv','wb');

$dishes = $db->query('SELECT dish_name, price, is_spicy FROM dishes');

while ($row = $dishes->fetch(PDO::FETCH_NUM)) {
	// записать в массив $row данные в виде строки
	// формата CSV. Функция fputcsv() добавляет
	// знак перевода строки в конце записываемой строки
	fputcsv($fh, $row);
}
fclose($fh);

/*
Чтобы отправить веб-клиенту обратно страницу, состоящую только из данных в формате CSV,
функции fputcsv() нужно дать команду направить данные в стандартный для РНР поток вывода
вместо записи в файл. Необходимо также вызвать встроенную в РНР функцию header(), чтобы
уведомить веб-клиента, что ему предполагается передать документ формата CSV, а не HTML. В
примере 9.12 показано, каким образом функция header() вызывается с соответствующими аргу-
ментами.
*/
Пример 9.12. Смена типа страницы на CSV

// уведомить веб-клиента, что ему предполагается передать
// файл формата CSV
header('Content-Type: text/csv');
// уведомить веб-клиента, что содержимое файла формата CSV
// следует просматривать в отдельной программе
header('Content-Disposition: attachment; filename="dishes.csv"');

/*
В примере 9.13 показана законченная программа, посылающая правильный заголовок в формате
CSV, извлекающая строки из таблицы базы данных и выводящая их на экран. Результат, выводи-
мый из этой программы, может быть непосредственно загружен в программу электронных таблиц
из веб-браузера пользователя.
*/

Пример 9.13. Отправка файла формата CSV браузеру

try {
	$db = new PDO('mysql:host=localhost; dbname=test_db', 'root', '');
} catch (Exception $e) {
	print "Couldn't connect to database: " . $e->getMessage();
exit();
}

// уведомить веб-клиента, что ему передается файл формата CSV
// под названием dishes.csv
header('Content-Type: text/csv');
header('Content-Disposition: attachment; filename="dishes.csv"');
// открыть файл с дескриптором потока вывода
$fh = fopen('php://output', 'wb');
// извлечь информацию из таблицы базы данных и
// вывести ее на экран
$dishes = $db->query('SELECT dish_name, price, is_spicy FROM dishes');

while ($row = $dishes->fetch(PDO::FETCH_NUM)) {
fputcsv($fh, $row);
}

/*
В коде из примера 9.13 в качестве аргумента функции fputcsv() передается php://output —
встроенный дескриптор файла, специально предназначенный для отправки данных туда же, куда они
выводятся по команде print. Чтобы сформировать более сложные электронные таблицы, включа-
ющие в себя формулы, изображения и средства форматирования, следует воспользоваться пакетом
PHPExcel (https://packagist.org/packages/phpoffice/phpexcel) из библиотечного на-
бора РНРОffiсе.
*/